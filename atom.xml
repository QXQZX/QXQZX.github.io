<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QXQZX&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://letcoder.cn/"/>
  <updated>2020-06-14T06:40:03.956Z</updated>
  <id>https://letcoder.cn/</id>
  
  <author>
    <name>QXQZX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 基础之反射</title>
    <link href="https://letcoder.cn/2020/06/14/go-reflect/"/>
    <id>https://letcoder.cn/2020/06/14/go-reflect/</id>
    <published>2020-06-14T05:02:09.000Z</published>
    <updated>2020-06-14T06:40:03.956Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>众所周知，反射是框架设计的灵魂。反射在很多语言中都有其妙用。在计算机科学领域，反射是指一类应用，它们能够<strong>自描述</strong>和<strong>自控制</strong>。本文将对于Golang的反射的笔记。</p><a id="more"></a><h3 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h3><p>Golang提供了一种机制，在编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。</p><h3 id="为什么用反射"><a href="#为什么用反射" class="headerlink" title="为什么用反射"></a>为什么用反射</h3><p>目的就是增加程序的灵活性，避免将程序写死在代码里。借助反射透视一个未知的类型。</p><blockquote><p><a href="http://shouce.jb51.net/gopl-zh/ch12/ch12-01.html" target="_blank" rel="noopener">为何需要反射?</a></p></blockquote><h3 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h3><p>reflect提供了两种类型来进行访问接口变量的内容</p><table><thead><tr><th>First Header</th><th style="text-align:center">Second Header</th></tr></thead><tbody><tr><td>reflect.ValueOf()</td><td style="text-align:center">获取输入参数接口中的数据的值，如果为空则返回<strong>0</strong> &lt;- 注意是0</td></tr><tr><td>reflect.TypeOf()</td><td style="text-align:center">动态获取输入参数接口中的值的类型，如果为空则返回<strong>nil</strong> &lt;- 注意是nil</td></tr></tbody></table><h4 id="简单的反射"><a href="#简单的反射" class="headerlink" title="简单的反射"></a>简单的反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"我是反射"</span></span><br><span class="line"><span class="comment">//TypeOf会返回目标数据的类型，比如int/float/struct/指针等</span></span><br><span class="line">reflectType := reflect.TypeOf(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf返回目标数据的的值，比如上文的"我是反射"</span></span><br><span class="line">reflectValue := reflect.ValueOf(name)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"type: "</span>, reflectType)</span><br><span class="line">fmt.Println(<span class="string">"value: "</span>, reflectValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:  string</span></span><br><span class="line"><span class="comment">//value:  我是反射</span></span><br></pre></td></tr></table></figure><h4 id="结构体的反射"><a href="#结构体的反射" class="headerlink" title="结构体的反射"></a>结构体的反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect</span><span class="params">(t <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">objT := reflect.TypeOf(t)</span><br><span class="line">objV := reflect.ValueOf(t)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取去这个类型的名称</span></span><br><span class="line">fmt.Println(<span class="string">"这个类型的名称是:"</span>, objT.Name())</span><br><span class="line">  </span><br><span class="line"><span class="comment">//通过.NumField()来获取结构体里的字段数量</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; objT.NumField(); i++ &#123;</span><br><span class="line"><span class="comment">//从0开始获取结构体所包含的key</span></span><br><span class="line">key := objT.Field(i)</span><br><span class="line"><span class="comment">//从0开始通过interface方法来获取key所对应的值</span></span><br><span class="line">value := objV.Field(i).Interface()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"第%d个字段是：%s:%v = %v \n"</span>, i+<span class="number">1</span>, key.Name, key.Type, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过.NumMethod()来获取结构体里的方法数量  这里只能获取 值接收器的方法。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; objT.NumMethod(); i++ &#123;</span><br><span class="line">m := objT.Method(i)</span><br><span class="line">fmt.Printf(<span class="string">"第%d个方法是：%s:%v\n"</span>, i+<span class="number">1</span>, m.Name, m.Type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := User&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">"反射"</span>,</span><br><span class="line">&#125;</span><br><span class="line">TestReflect(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个类型的名称是: User</span><br><span class="line">第1个字段是：Id:int = 1 </span><br><span class="line">第2个字段是：Name:string = 反射 </span><br><span class="line">第1个方法是：Hello:func(main.User)</span><br></pre></td></tr></table></figure><h4 id="匿名或嵌入字段的反射"><a href="#匿名或嵌入字段的反射" class="headerlink" title="匿名或嵌入字段的反射"></a>匿名或嵌入字段的反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Student <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := User&#123;Student&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">"反射"</span>,</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line"><span class="comment">//这里需要加一个#号，可以把struct的详情都给打印出来</span></span><br><span class="line"><span class="comment">//会发现有Anonymous:true，说明是匿名字段</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, t.Field(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取匿名字段的值的详情</span></span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, v.Field(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reflect.StructField&#123;Name:&quot;Student&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0x10bb640), Tag:&quot;&quot;, Offset:0x0, Index:[]int&#123;0&#125;, Anonymous:true&#125;</span><br><span class="line">reflect.StructField&#123;Name:&quot;Name&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0x10ae120), Tag:&quot;&quot;, Offset:0x8, Index:[]int&#123;1&#125;, Anonymous:false&#125;</span><br><span class="line">main.Student&#123;Id:1, Name:&quot;反射&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="用反射判断传入的类型"><a href="#用反射判断传入的类型" class="headerlink" title="用反射判断传入的类型"></a>用反射判断传入的类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := Student&#123;Id: <span class="number">1</span>, Name: <span class="string">"反射"</span>&#125;</span><br><span class="line">t := reflect.TypeOf(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过.Kind()来判断对比的值是否是struct类型</span></span><br><span class="line"><span class="keyword">if</span> k := t.Kind(); k == reflect.Struct &#123;</span><br><span class="line">fmt.Println(<span class="string">"bingo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num := <span class="number">1</span>;</span><br><span class="line">numType := reflect.TypeOf(num)</span><br><span class="line"><span class="keyword">if</span> k := numType.Kind(); k == reflect.Int &#123;</span><br><span class="line">fmt.Println(<span class="string">"bingo"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">bingo</span></span><br><span class="line"><span class="comment">bingo</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="通过反射修改内容"><a href="#通过反射修改内容" class="headerlink" title="通过反射修改内容"></a>通过反射修改内容</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Student <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := &amp;User&#123;Student&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">"反射"</span>,</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"><span class="comment">//修改值必须是指针类型</span></span><br><span class="line"><span class="keyword">if</span> v.Kind() != reflect.Ptr &#123;</span><br><span class="line">fmt.Println(<span class="string">"不是指针类型，无法进行修改操作"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取指针所指向的元素</span></span><br><span class="line">v = v.Elem()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, *u)</span><br><span class="line">name := v.FieldByName(<span class="string">"Name"</span>)</span><br><span class="line"><span class="keyword">if</span> name.Kind() == reflect.String &#123;</span><br><span class="line">name.SetString(<span class="string">"小学生"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, *u)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是整型的话</span></span><br><span class="line">test := <span class="number">888</span></span><br><span class="line">testV := reflect.ValueOf(&amp;test)</span><br><span class="line">testV.Elem().SetInt(<span class="number">666</span>)</span><br><span class="line">fmt.Println(test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.User&#123;Student:main.Student&#123;Id:1, Name:&quot;反射&quot;&#125;&#125;</span><br><span class="line">main.User&#123;Student:main.Student&#123;Id:1, Name:&quot;小学生&quot;&#125;&#125;</span><br><span class="line">666</span><br></pre></td></tr></table></figure><h4 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">Hello</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello, "</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := Student&#123;</span><br><span class="line">Id:   <span class="number">1</span>,</span><br><span class="line">Name: <span class="string">"反射"</span>,</span><br><span class="line">&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法控制权 返回v的名为name的方法的已绑定（到v的持有值的）状态的函数形式的Value封装</span></span><br><span class="line">method := v.MethodByName(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="comment">//拼凑参数</span></span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(<span class="string">"反射"</span>)&#125;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">method.Call(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,  反射</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p><ul><li>反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地<ul><li>反射必须结合interface才玩得转</li><li>变量的type要是concrete type的（也就是interface变量）才有反射一说</li></ul></li><li>反射可以将“接口类型变量”转换为“反射类型对象”<ul><li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li></ul></li><li>反射可以将“反射类型对象”转换为“接口类型变量<ul><li>reflect.value.Interface().(已知的类型)</li><li>遍历reflect.Type的Field获取其Field</li></ul></li><li>反射可以修改反射类型对象，但是其值必须是“addressable”<ul><li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</li></ul></li><li>通过反射可以“动态”调用方法</li><li>因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</li></ul><p>Golang的反射很慢，这个和它的API设计有关。Golang reflect慢主要有两个原因</p><ol><li>涉及到内存分配以及后续的GC；</li><li>reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。</li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://shouce.jb51.net/gopl-zh/ch12/ch12.html" target="_blank" rel="noopener">Go语言圣经</a></li><li><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">标准库文档</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;众所周知，反射是框架设计的灵魂。反射在很多语言中都有其妙用。在计算机科学领域，反射是指一类应用，它们能够&lt;strong&gt;自描述&lt;/strong&gt;和&lt;strong&gt;自控制&lt;/strong&gt;。本文将对于Golang的反射的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Go基础" scheme="https://letcoder.cn/categories/Go%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang" scheme="https://letcoder.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 组合取代继承</title>
    <link href="https://letcoder.cn/2020/04/07/go-composition/"/>
    <id>https://letcoder.cn/2020/04/07/go-composition/</id>
    <published>2020-04-07T13:26:54.000Z</published>
    <updated>2020-04-07T14:08:10.491Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>Go 不支持继承，但它支持组合（Composition）。组合一般定义为“合并在一起”，即将几个结构体嵌套起来构成大的结构体类型。汽车就是一个关于组合的例子：一辆汽车由车轮、引擎和其他各种部件组合在一起。</p><a id="more"></a><p>组合的典型例子就是博客博文。每一个博客的博文都有标题、内容、发表时间和作者信息。使用组合可以很好地表示它们。网站结构体中 放有 文章结构体，文章结构体中 放有 作者信息结构体。下面用代码实现。</p><h3 id="通过嵌套结构体进行组合"><a href="#通过嵌套结构体进行组合" class="headerlink" title="通过嵌套结构体进行组合"></a>通过嵌套结构体进行组合</h3><p>首先定义一个作者信息author结构体和一个获取作者信息的方法<code>fullName()</code>方法，其中 <code>author</code> 作为接收者类型，该方法返回了作者的全名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> author <span class="keyword">struct</span> &#123;</span><br><span class="line">firstName <span class="keyword">string</span></span><br><span class="line">lastName  <span class="keyword">string</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取作者的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a author)</span> <span class="title">fullName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s"</span>, a.firstName, a.lastName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面定义一个 博文信息post结构体，以及他的一个方法。它有一个嵌套的匿名字段 <code>author</code>。该字段指定 <code>author</code> 组成了 <code>post</code> 结构体。现在 <code>post</code> 可以访问 <code>author</code> 结构体的<strong>所有字段和方法</strong>。我们同样给 <code>post</code> 结构体添加了 <code>details()</code> 方法，用于打印标题、内容和作者的信息。</p><p>关键知识点： 一旦结构体A内嵌套了一个结构体B，Go 可以使我们访问嵌套的B的所有字段和方法，好像这些字段属于外部结构体一样。所以下面的 <code>p.author.fullName()</code> 可以替换为 <code>p.fullName()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> post <span class="keyword">struct</span> &#123;</span><br><span class="line">title   <span class="keyword">string</span></span><br><span class="line">content <span class="keyword">string</span></span><br><span class="line">author  <span class="comment">// 嵌套author结构体 **这里会自动组合author的所有方法和字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p post)</span> <span class="title">details</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"title: "</span>, p.title)</span><br><span class="line">fmt.Println(<span class="string">"content: "</span>, p.content)</span><br><span class="line"><span class="comment">// fmt.Println("author: ", p.author.fullName())</span></span><br><span class="line">fmt.Println(<span class="string">"author: "</span>, p.fullName()) <span class="comment">// 自动组合author的所有方法和字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> author <span class="keyword">struct</span> &#123;</span><br><span class="line">firstName <span class="keyword">string</span></span><br><span class="line">lastName  <span class="keyword">string</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取作者的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a author)</span> <span class="title">fullName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s"</span>, a.firstName, a.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> post <span class="keyword">struct</span> &#123;</span><br><span class="line">title   <span class="keyword">string</span></span><br><span class="line">content <span class="keyword">string</span></span><br><span class="line">author  <span class="comment">// 嵌套author结构体 **这里会自动组合author的所有方法和字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p post)</span> <span class="title">details</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"title: "</span>, p.title)</span><br><span class="line">fmt.Println(<span class="string">"content: "</span>, p.content)</span><br><span class="line"><span class="comment">//fmt.Println("author: ", p.author.fullName())</span></span><br><span class="line">fmt.Println(<span class="string">"author: "</span>, p.fullName()) <span class="comment">// 自动组合author的所有方法和字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">author1 := author&#123;</span><br><span class="line">firstName: <span class="string">"gh"</span>,</span><br><span class="line">lastName:  <span class="string">"z"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">post1 := post&#123;</span><br><span class="line">title:   <span class="string">"1"</span>,</span><br><span class="line">content: <span class="string">"1111"</span>,</span><br><span class="line">author:  author1,</span><br><span class="line">&#125;</span><br><span class="line">post1.details()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title:  1</span><br><span class="line">content:  1111</span><br><span class="line">author:  gh z</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="结构体切片的嵌套"><a href="#结构体切片的嵌套" class="headerlink" title="结构体切片的嵌套"></a>结构体切片的嵌套</h3><p>结合上面代码，我们加入一个website结构体，一个website结构体中包含多个post结构体，所以采用一个切片来存储。</p><p><strong>注意：</strong>结构体不能嵌套一个匿名切片。我们需要一个字段名。所以我们来修复这个错误，让编译器顺利通过。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> author <span class="keyword">struct</span> &#123;</span><br><span class="line">firstName <span class="keyword">string</span></span><br><span class="line">lastName  <span class="keyword">string</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取作者的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a author)</span> <span class="title">fullName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s"</span>, a.firstName, a.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> post <span class="keyword">struct</span> &#123;</span><br><span class="line">title   <span class="keyword">string</span></span><br><span class="line">content <span class="keyword">string</span></span><br><span class="line">author  <span class="comment">// 嵌套author结构体 **这里会自动组合author的所有方法和字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p post)</span> <span class="title">details</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"title: "</span>, p.title)</span><br><span class="line">fmt.Println(<span class="string">"content: "</span>, p.content)</span><br><span class="line"><span class="comment">//fmt.Println("author: ", p.author.fullName())</span></span><br><span class="line">fmt.Println(<span class="string">"author: "</span>, p.fullName()) <span class="comment">// 自动组合author的所有方法和字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站</span></span><br><span class="line"><span class="keyword">type</span> website <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//[]post 匿名切片报错</span></span><br><span class="line">posts []post</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看遍历文章</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w website)</span> <span class="title">view</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"view website"</span>)</span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> w.posts &#123;</span><br><span class="line">p.details()</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">author1 := author&#123;</span><br><span class="line">firstName: <span class="string">"gh"</span>,</span><br><span class="line">lastName:  <span class="string">"z"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">post1 := post&#123;</span><br><span class="line">title:   <span class="string">"1"</span>,</span><br><span class="line">content: <span class="string">"1111"</span>,</span><br><span class="line">author:  author1,</span><br><span class="line">&#125;</span><br><span class="line">post2 := post&#123;</span><br><span class="line">title:   <span class="string">"2"</span>,</span><br><span class="line">content: <span class="string">"2222"</span>,</span><br><span class="line">author:  author1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w := website&#123;posts: []post&#123;post1, post2&#125;&#125;</span><br><span class="line">w.view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">view website</span><br><span class="line">title:  1</span><br><span class="line">content:  1111</span><br><span class="line">author:  gh z</span><br><span class="line"></span><br><span class="line">title:  2</span><br><span class="line">content:  2222</span><br><span class="line">author:  gh z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>在主函数中，我们创建了一个作者 <code>author1</code>，以及两篇博文 <code>post1</code>、<code>post2</code> 。我们最后通过嵌套两篇博文构成的切片，创建了网站 <code>w</code>，并在下一行调用website结构体的 view方法显示内容。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://studygolang.com/articles/12680" target="_blank" rel="noopener">Go系列教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Go 不支持继承，但它支持组合（Composition）。组合一般定义为“合并在一起”，即将几个结构体嵌套起来构成大的结构体类型。汽车就是一个关于组合的例子：一辆汽车由车轮、引擎和其他各种部件组合在一起。&lt;/p&gt;
    
    </summary>
    
      <category term="Go基础" scheme="https://letcoder.cn/categories/Go%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang" scheme="https://letcoder.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>2019年 年终总结</title>
    <link href="https://letcoder.cn/2019/12/31/2019-summary/"/>
    <id>https://letcoder.cn/2019/12/31/2019-summary/</id>
    <published>2019-12-31T14:54:50.000Z</published>
    <updated>2019-12-31T15:39:05.081Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>2019这一年，对我来说，可以说是变化非常大的一年。从刚刚进入大学，只会写c语言在oj刷题的渣渣，到今天可以独立完成网站前后端设计开发。这一路接受了很多了人的帮助，在此表示感谢，感谢付出和谆谆教导。</p><hr><h3 id="2019-1-2019-3"><a href="#2019-1-2019-3" class="headerlink" title="2019.1-2019.3"></a>2019.1-2019.3</h3><p>学习前端开发。从HTML、css到JavaScript。进行了系统的学习，包括css选择器，权重，各种布局，JavaScript闭包，预编译，继承， 作用链等，这些知识虽然学了也没咋用到过。更更不幸的是，其中很多的知识大部分遗忘。唉，太难了。</p><h3 id="2019-3-2019-6"><a href="#2019-3-2019-6" class="headerlink" title="2019.3-2019.6"></a>2019.3-2019.6</h3><p>转向学习Java后端开发，对JavaSE基础，注解、泛型、反射 以及MySQL数据库、servlet、cookie、session、等进行了系统学习。学完后，完成了一个小小的人员管理系统，跟着视频做的。之后顺利的通过选拔进入了学院的软件实验室，这也是我的转折点。</p><h3 id="2019-6-2019-9"><a href="#2019-6-2019-9" class="headerlink" title="2019.6-2019.9"></a>2019.6-2019.9</h3><p>进入实验室后，和学长组队参见了一个软件比赛，在做比赛项目的过程中学习了spring框架 、mybatis、springmvc等框架。不过仅限于会用，而且不太熟练。暑假留校，独立完成了基于人脸识别的宿舍考勤app的前后端设计与开发。app用html5写的，后端采用的ssm架构，结合json通过ajax通信。</p><h3 id="2019-9-今"><a href="#2019-9-今" class="headerlink" title="2019.9-今"></a>2019.9-今</h3><p>虽然学了很多的框架和技术，但这也只是皮毛。我意识到自己的很多的不足之处，其中最为致命的是基础知识不够扎实，遇到不确定的代码就得上百度搜索一番，唉，太难了。之后我边学框架，边补自己的不足之处。还有最重要的就是学习数据结构和算法了，因为这学期开数据结构了。这门课挺重要的。</p><p>现在手头上有一个给学校开发的辅导员在线考试系统。用vue + axios + springBoot + mysql + redis+ mybatis 开发的前后端分离的项目。正在开发中，项目不是很大。但总能得到一些锻炼。</p><p>最近很忙，因为有数据结构与算法实训。实训主要内容是 用c语言写了几个小项目，班级学生管理系统、电子词典和车站车次管理系统等，上手不是很轻松，尤其是多维指针那一块。我又又又意识到自己真的基础很不扎实。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说吧，这一年来进步还是挺大的，还算满意。但同时也越来越觉得自己的基础不是很好，虽然学的东西不少，但都不扎实。接下来要做的就是 好好学习专业课，补自己的短板。还有下学期专业课挺多的，操作系统和计算机组成原理，不知道难度如何。</p><p>吧啦吧啦，就这些吧。2019年过去了，有进步也有不足，所以2020年继续加油吧。争取在大学三下考研 或者 拿到一线大厂offer。</p><blockquote><p>少抱怨，多思考，明天会更美好。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;2019这一年，对我来说，可以说是变化非常大的一年。从刚刚进入大学，只会写c语言在oj刷题的渣渣，到今天可以独立完成网站前后端设计开发。这一路接
      
    
    </summary>
    
      <category term="杂谈" scheme="https://letcoder.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="https://letcoder.cn/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Git服务器并部署Hexo站点</title>
    <link href="https://letcoder.cn/2019/12/15/build-own-gitServer/"/>
    <id>https://letcoder.cn/2019/12/15/build-own-gitServer/</id>
    <published>2019-12-15T10:44:57.000Z</published>
    <updated>2019-12-15T13:09:11.810Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前自己的博客站点是托管在Github的，使用过Netlify，coding，但速度都不是很理想。也曾使用过Gitee(速度虽然不从，但绑定域名要付费99， 放弃 )。最近买了阿里云的学生机来玩，国内速度还不错，1核2G5Mbps。所以今天计划把自己原来托管在github的网站迁移到阿里云服务器。迁移过程还算顺利。</p><p>我迁移大体的思路是，继续用hexo部署。搭建自己的git服务器，然后用hexo部署到自己的git服务器。然后通过nginx挂载git仓库，实现全静态访问。速度可想而知。</p><p>开始操作</p><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y git</span><br></pre></td></tr></table></figure><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>先创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adduser git <span class="comment"># 添加git用户 用于ssh</span></span><br><span class="line">$ passwd git <span class="comment"># 设置刚添加的用户密码 用于以后的push 和 clone</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>home/git</code> 的目录下，创建一个名为<code>hexoBlog</code>的裸仓库（bare repo）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/git/</span><br><span class="line">$ git init --bare hexoBlog.git <span class="comment"># git会创建一个裸仓库</span></span><br></pre></td></tr></table></figure><p>上面已经创建的裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git /home/git/hexoBlog.git</span><br></pre></td></tr></table></figure><p>禁用shell登录：</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>克隆远程仓库：</p><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在自己的电脑上运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@server:/home/git/hexoBlog.git <span class="comment"># server 为ip</span></span><br><span class="line">Cloning into <span class="string">'hexoBlog'</span>...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure><p>出现上面信息，基本说明搭建完毕，剩下的推送就简单了。</p><h3 id="创建Hooks钩子"><a href="#创建Hooks钩子" class="headerlink" title="创建Hooks钩子"></a>创建Hooks钩子</h3><p>创建hooks钩子的目的是把，git仓库里的代码拉到一个路径下，便于查看修改和以后的nginx挂载</p><p>在hooks下创建<strong>post-receive</strong>脚本，它将在仓库接收到push时执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ vim /home/git/hexoBlog.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">git --work-tree=/home/hexoBlog --git-dir=/home/git/hexoBlog.git checkout -f</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'拉取完毕'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改完毕，给足权限 巨坑</span></span><br><span class="line">$ chmod +x /home/git/hexoBlog.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 /home/hexoBlog 存放源码</span></span><br><span class="line">$ mkdir /home/hexoBlog</span><br></pre></td></tr></table></figure><p>写到这里，用户组对/home/hexoBlog路径只有读的权限，没有写的权限。上边的配置都没有什么问题，就这个权限折腾了一天，用户组默认的权限是没有写权限的，配置好不能上传代码，问题就在用户组的权限。<br>修改目录及其子文件的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod -R 777 /home/hexoBlog <span class="comment"># 让所有用户有操作权限</span></span><br></pre></td></tr></table></figure><p>之后push之后就可以在 /home/hexoBlog看到push的文件了</p><hr><h2 id="部署hexo网站"><a href="#部署hexo网站" class="headerlink" title="部署hexo网站"></a>部署hexo网站</h2><h3 id="云服务器端配置-Nginx"><a href="#云服务器端配置-Nginx" class="headerlink" title="云服务器端配置 Nginx"></a>云服务器端配置 Nginx</h3><p>安装 启动 测试Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y nginx</span><br><span class="line"><span class="comment"># 启动 Nginx</span></span><br><span class="line">$ systemctl start nginx</span><br><span class="line"><span class="comment"># 测试 Nginx 服务器</span></span><br><span class="line">$ wget http://127.0.0.1</span><br></pre></td></tr></table></figure><p>能够正常获取以下欢迎页面说明Nginx安装成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connecting to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">80.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">200</span> OK</span><br><span class="line">Length: <span class="number">43704</span> (<span class="number">43</span>K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line"><span class="number">100</span>%[=======================================&gt;] <span class="number">43</span>,<span class="number">704</span>      --.-K/s   <span class="keyword">in</span> <span class="number">0</span>s</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-15</span> <span class="number">23</span>:<span class="number">04</span>:<span class="number">09</span> (<span class="number">487</span> MB/s) - ‘index.html’ saved [<span class="number">43704</span>/<span class="number">43704</span>]</span><br></pre></td></tr></table></figure><p>查看 Nginx 的默认配置的安装位置</p><p>nginx -t</p><p>修改Nginx的默认配置，其中 vim 后边就是刚才查到的安装位置（每个人可能都不一样）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/nginx/nginx.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到location / &#123;&#125;</span></span><br><span class="line"><span class="comment"># root为静态文件存放地址 也就是仓库</span></span><br><span class="line">location / &#123;</span><br><span class="line">  root /home/hexoBlog;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Nginx 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart nginx</span><br></pre></td></tr></table></figure><p>至此，服务器端配置就结束了。接下来，就剩下本地 hexo 的配置更改了。</p><h3 id="修改-hexo-站点配置文件-git-相关设置"><a href="#修改-hexo-站点配置文件-git-相关设置" class="headerlink" title="修改 hexo 站点配置文件 git 相关设置"></a>修改 hexo 站点配置文件 git 相关设置</h3><p>打开你本地的 hexo 博客所在文件，打开站点配置文件（不是主题配置文件），做以下修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">    repo:</span> <span class="string">git@你的云服务器的IP地址:/home/git/hexoBlog</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>在 hexo 目录下执行部署，试试看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> 你的hexo目录</span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p>打开你的公网 IP，看是不是已经部署成功了。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://cloud.tencent.com/developer/article/1140005" target="_blank" rel="noopener">Hexo 博客部署到腾讯云教程</a></li><li><a href="https://blog.csdn.net/qq_35561857/article/details/81590953" target="_blank" rel="noopener">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664" target="_blank" rel="noopener">搭建Git服务器</a></li><li><a href="https://yq.aliyun.com/articles/640997" target="_blank" rel="noopener">将Hexo博客部署到云主机</a></li><li><a href="https://blog.csdn.net/u010258933/article/details/80663805" target="_blank" rel="noopener">Linux系统搭建Git服务器，添加用户名密码实现多用户管理</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;以前自己的
      
    
    </summary>
    
      <category term="git" scheme="https://letcoder.cn/categories/git/"/>
    
    
      <category term="Hexo" scheme="https://letcoder.cn/tags/Hexo/"/>
    
      <category term="git" scheme="https://letcoder.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>AVL平衡二叉树学习</title>
    <link href="https://letcoder.cn/2019/12/14/AVL-tree/"/>
    <id>https://letcoder.cn/2019/12/14/AVL-tree/</id>
    <published>2019-12-14T13:16:49.000Z</published>
    <updated>2019-12-21T01:48:34.634Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p><strong>平衡二叉树(AVL)，</strong>是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。高度平衡？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</p><a id="more"></a><h3 id="平衡二叉树特点"><a href="#平衡二叉树特点" class="headerlink" title="平衡二叉树特点"></a>平衡二叉树特点</h3><p><strong>平衡因子BF：</strong><br>指的是二叉树左子树深度减去右子树深度。<br>平衡因子只能是-1,0,1。只要二叉树有一个节点的平衡因子绝对值大于1，则该树就不平衡了。</p><p>一棵AVL树有如下必要条件：</p><ol><li>条件一：它必须是二叉排序树。</li><li>条件二：每个节点的左子树和右子树的高度差至多为1。也就是说平衡因子绝对值不超过1</li></ol><h3 id="实用性分析"><a href="#实用性分析" class="headerlink" title="实用性分析"></a>实用性分析</h3><p>AVL平衡二叉树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），这得益于它时刻维护着二叉树的平衡。如果我们需要查找的集合本身没有顺序，在频繁查找的同时也经常的插入和删除，AVL树是不错的选择。不平衡的二叉查找树在查找时的效率是很低的，因此，AVL如何维护二叉树的平衡是我们的学习重点。</p><hr><h3 id="四种旋转方式"><a href="#四种旋转方式" class="headerlink" title="四种旋转方式"></a>四种旋转方式</h3><p><img src="https://tvax3.sinaimg.cn/large/006nIlf0ly1g9wkw68fdvj319s0oegph.jpg" alt="旋转方式"></p><h4 id="LL型旋转"><a href="#LL型旋转" class="headerlink" title="LL型旋转"></a>LL型旋转</h4><p>由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B顺时针旋转一样。</p><p>LL型调整的一般形式如下图所示，表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。</p><p><img src="https://tva2.sinaimg.cn/large/006nIlf0ly1g9wl6dpfngj30ms0a3mxe.jpg" alt></p><h4 id="RR型旋转"><a href="#RR型旋转" class="headerlink" title="RR型旋转"></a>RR型旋转</h4><p>和LL型旋转类似</p><p>表示在A的右孩子B的右子树BR(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将A的右孩子B提升为新的根结点；②将原来的根结点A降为B的左孩子；③各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。</p><p><img src="https://tva1.sinaimg.cn/large/006nIlf0ly1g9wl6izdyqj30mi0agq36.jpg" alt></p><h4 id="LR型旋转"><a href="#LR型旋转" class="headerlink" title="LR型旋转"></a>LR型旋转</h4><p>表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的右孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子，B变为C的左孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。</p><p><img src="https://tva1.sinaimg.cn/large/006nIlf0ly1g9wlbzq4lhj30nv0ant94.jpg" alt></p><p><strong>等价于 先一次RR旋转再一次LL旋转。先对B右孩子C及C的右孩子进行RR旋转，再对A,B,C进行LL旋转。</strong></p><p><img src="https://tva1.sinaimg.cn/large/006nIlf0ly1g9wlpkpjw3j30m906njs4.jpg" alt></p><h4 id="RL型旋转"><a href="#RL型旋转" class="headerlink" title="RL型旋转"></a>RL型旋转</h4><p>表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子，B变为C的右孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。</p><p><img src="https://tva4.sinaimg.cn/large/006nIlf0ly1g9wlc3skaej30nc0a23yy.jpg" alt></p><p><strong>等价于 先一次LL旋转再一次RR旋转。先对B左孩子C及C的左孩子进行LL旋转，再对A,B,C进行RR旋转。</strong></p><p><img src="https://tvax2.sinaimg.cn/large/006nIlf0ly1g9wlpmyadhj30m706nmxx.jpg" alt></p><hr><h3 id="C-C-代码实现"><a href="#C-C-代码实现" class="headerlink" title="C/C++代码实现"></a>C/C++代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E [3374] - 数据结构实验之查找二：平衡二叉树</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">//记录关键字数值</span></span><br><span class="line">    node *l, *r;</span><br><span class="line">    <span class="keyword">int</span> height;  <span class="comment">//当前节点的高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(node *p)</span>  <span class="comment">//求树的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">LL</span><span class="params">(node *p)</span>  <span class="comment">//对LL型直接在不平衡结点进行左旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *q = p-&gt;l;  <span class="comment">// q是p的左子树</span></span><br><span class="line">    p-&gt;l = q-&gt;r;  <span class="comment">// q的右子树值一定小于p-&gt;data  所以p-&gt;l连上q-&gt;r</span></span><br><span class="line">    q-&gt;r = p;     <span class="comment">// q-&gt;r连上p 画图理解</span></span><br><span class="line">    p-&gt;height = max(height(p-&gt;l), height(p-&gt;r)) + <span class="number">1</span>;  <span class="comment">// 要更新结点的高度值</span></span><br><span class="line">    q-&gt;height = max(height(q-&gt;l), p-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">RR</span><span class="params">(node *p)</span>  <span class="comment">//对RR型直接在不平衡结点进行右旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *q = p-&gt;r;  <span class="comment">// 连接原理与LL相同</span></span><br><span class="line">    p-&gt;r = q-&gt;l;</span><br><span class="line">    q-&gt;l = p;</span><br><span class="line">    p-&gt;height = max(height(p-&gt;l), height(p-&gt;r)) + <span class="number">1</span>;</span><br><span class="line">    q-&gt;height = max(height(q-&gt;r), p-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">LR</span><span class="params">(node *p)</span> </span>&#123;</span><br><span class="line">    p-&gt;l = RR(p-&gt;l);  <span class="comment">//在不平衡结点p的左孩子以及左孩子的孩子进行RR旋转</span></span><br><span class="line">    <span class="keyword">return</span> LL(p);  <span class="comment">//在不平衡结点p处进行LL并返回新的根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">RL</span><span class="params">(node *p)</span> </span>&#123;</span><br><span class="line">    p-&gt;r = LL(p-&gt;r);  <span class="comment">//在不平衡结点p的右孩子以及右孩子的孩子进行LL旋转</span></span><br><span class="line">    <span class="keyword">return</span> RR(p);  <span class="comment">//在不平衡结点p处进行RR并返回新的根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//待插入的值赋给新开辟的结点</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> node;</span><br><span class="line">        p-&gt;data = k;</span><br><span class="line">        p-&gt;height = <span class="number">0</span>;</span><br><span class="line">        p-&gt;l = p-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;data) &#123;</span><br><span class="line">        <span class="comment">// 若待插入的值小于p的关键字数值，则插入到左子树中</span></span><br><span class="line">        insert(p-&gt;l, k);</span><br><span class="line">        <span class="comment">// 若该树出现不平衡 旋转</span></span><br><span class="line">        <span class="keyword">if</span> (height(p-&gt;l) - height(p-&gt;r) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; p-&gt;l-&gt;data)  <span class="comment">// 若待插入的值插到了左子树的左子树上则单旋转</span></span><br><span class="line">                p = LL(p);</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//若待插入的值插到了左子树的右子树上则单旋转</span></span><br><span class="line">                p = LR(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; p-&gt;data) &#123;</span><br><span class="line">        <span class="comment">// 若待插入的值小于p的关键字数值，则插入到右子树中</span></span><br><span class="line">        insert(p-&gt;r, k);</span><br><span class="line">        <span class="keyword">if</span> (height(p-&gt;r) - height(p-&gt;l) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 若待插入的值插到了右子树的右子树上则单旋转</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; p-&gt;r-&gt;data)</span><br><span class="line">                p = RR(p);</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 若待插入的值插到了右子树的左子树上则单旋转</span></span><br><span class="line">                p = RL(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;height = max(height(p-&gt;l), height(p-&gt;r)) + <span class="number">1</span>;  <span class="comment">// 修改高度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        node *head = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            insert(head, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推荐学习资料"><a href="#推荐学习资料" class="headerlink" title="推荐学习资料"></a>推荐学习资料</h3><p>b站视频连接：<br><a href="https://www.bilibili.com/video/av37955102?from=search&amp;seid=14638889623357631324" target="_blank" rel="noopener">https://www.bilibili.com/video/av37955102?from=search&amp;seid=14638889623357631324</a></p><p><a href="https://www.bilibili.com/video/av37955178?from=search&amp;seid=14638889623357631324" target="_blank" rel="noopener">https://www.bilibili.com/video/av37955178?from=search&amp;seid=14638889623357631324</a></p><p><a href="https://www.bilibili.com/video/av37955231?from=search&amp;seid=14638889623357631324" target="_blank" rel="noopener">https://www.bilibili.com/video/av37955231?from=search&amp;seid=14638889623357631324</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/isunbin/article/details/81707606" target="_blank" rel="noopener">平衡二叉树</a></li><li><a href></a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;平衡二叉树(AVL)，&lt;/strong&gt;是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。高度平衡？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://letcoder.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://letcoder.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="https://letcoder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>equals与==的区别</title>
    <link href="https://letcoder.cn/2019/11/26/equals%E4%B8%8E%E7%AD%89%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://letcoder.cn/2019/11/26/equals与等于等于的区别/</id>
    <published>2019-11-26T14:14:52.000Z</published>
    <updated>2019-11-26T14:17:46.626Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><h3 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h3><p>一、基本数据类型 用(==) 进行比较的时候，比较的实际值</p><p>二、包装数据类型 用(==)进行比较的时候，比较的是在内存中存放的地址</p><p>三、包装类型中的equals方法，（String，Integer，Date）等重写了equals方法，比较的是地址和内容，地址相同返回true，地址不同但值相同返回true，其他返回false。没有重写equals方法的，比较的还是内存地址。</p><p>四、StringBuffer 和 StringBuilder 比较特殊， == 和 equals都是比较的地址。</p><hr><p>推荐文章</p><p><a href="https://blog.csdn.net/qq_36522306/article/details/80550210" target="_blank" rel="noopener">https://blog.csdn.net/qq_36522306/article/details/80550210</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;equals与-的区别&quot;&gt;&lt;a href=&quot;#equals与-的区别&quot; class=&quot;headerlink&quot; title=&quot;equal
      
    
    </summary>
    
      <category term="Java基础" scheme="https://letcoder.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>静态工厂和实例工厂区别</title>
    <link href="https://letcoder.cn/2019/10/19/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E5%8C%BA%E5%88%AB/"/>
    <id>https://letcoder.cn/2019/10/19/静态工厂和实例工厂区别/</id>
    <published>2019-10-19T08:22:02.000Z</published>
    <updated>2019-12-13T12:42:01.846Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>在学习Spring bean的实例化方式的时候遇到的一个问题，Spring bean实例化有3种方法</p><ul><li>通过类的构造器生成</li><li>通过静态工厂方法创建</li><li>通过实例工厂方法创建</li></ul><p>那么问题来了，什么是静态工厂方法，什么是实例工厂方法？两者有什么区别呢？</p><h2 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h2><blockquote><p>就是直接可以通过静态方法来实例化一个对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloWorld <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建的时候</span></span><br><span class="line">HelloWorldFactory.getInstance();</span><br></pre></td></tr></table></figure><blockquote><p>创建 HelloWorld 对象直接可以调用getInstance方法来进行实现</p></blockquote><h2 id="实例工厂方法"><a href="#实例工厂方法" class="headerlink" title="实例工厂方法"></a>实例工厂方法</h2><blockquote><p>就是先创建类对象，如何通过对象来调用创建实例对象的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">createHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建的时候</span></span><br><span class="line">HelloWorldFactory helloFactory = <span class="keyword">new</span> HelloWorldFactory();</span><br><span class="line">helloFactory.createHelloWorld();</span><br></pre></td></tr></table></figure><h1 id="关于applicationContext-xml"><a href="#关于applicationContext-xml" class="headerlink" title="关于applicationContext.xml"></a>关于applicationContext.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        创建对象的第二种方式：利用静态工厂方法</span></span><br><span class="line"><span class="comment">        factory-method：静态工厂类的获取对象的静态方法</span></span><br><span class="line"><span class="comment">        class:静态工厂类的全类名</span></span><br><span class="line"><span class="comment">静态工厂方法 工厂不需要实例化</span></span><br><span class="line"><span class="comment"> --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"HelloStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstances"</span> <span class="attr">class</span>=<span class="string">"com.coder.ioc.HelloStaticFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        创建对象的第三种方式：利用实例工厂方法</span></span><br><span class="line"><span class="comment">        factory-bean:指定当前Spring中包含工厂方法的beanID</span></span><br><span class="line"><span class="comment">        factory-method:工厂方法名称</span></span><br><span class="line"><span class="comment">实例工厂方法是先将工厂实例化</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"HelloInstanceFactory"</span> <span class="attr">class</span>=<span class="string">"com.coder.ioc.HelloInstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instance"</span> <span class="attr">factory-bean</span>=<span class="string">"HelloInstanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在学习Spring bean的实例化方式的时候遇到的一个问题，Spring bean实例化有3种方法&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过类的构造器生成&lt;
      
    
    </summary>
    
      <category term="Java后端" scheme="https://letcoder.cn/categories/Java%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java注解学习</title>
    <link href="https://letcoder.cn/2019/10/07/Java-annotation/"/>
    <id>https://letcoder.cn/2019/10/07/Java-annotation/</id>
    <published>2019-10-07T13:28:44.000Z</published>
    <updated>2019-12-15T06:33:45.690Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>注释：用文字描述程序，给程序员看的</p><p>注解：给机器看的</p><a id="more"></a><h2 id="1-注解基础知识点"><a href="#1-注解基础知识点" class="headerlink" title="1.注解基础知识点"></a>1.注解基础知识点</h2><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p><h3 id="1-1作用分类："><a href="#1-1作用分类：" class="headerlink" title="1.1作用分类："></a>1.1作用分类：</h3><p>①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</p><p>②代码分析：通过代码里标识的元数据对代码进行分析【使用反射】</p><p>③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查，编译检查是否是复写父类的方法【Override】</p><p>给某个类、方法..添加了一个注解，这个环节仅仅是做了一个标记，对代码本身并不会造成任何影响，需要后续环节的配合，需要其他方法对该注解赋予业务逻辑处理。就如同我们在微信上发了一个共享定位，此时并没有什么用，只有当后面其他人都进入了这个共享定位，大家之间的距离才能明确，才知道该怎么聚在一起。</p><h3 id="1-2注解分为三类："><a href="#1-2注解分为三类：" class="headerlink" title="1.2注解分为三类："></a>1.2注解分为三类：</h3><h4 id="1-2-1编译器使用到的注解"><a href="#1-2-1编译器使用到的注解" class="headerlink" title="1.2.1编译器使用到的注解"></a>1.2.1编译器使用到的注解</h4><p>如@Override，@SuppressWarnings都是编译器使用到的注解，作用是告诉编译器一些事情，而不会进入编译后的.class文件。</p><p>@Override：告诉编译器检查一下是否重写了父类的方法；</p><p>@SuppressWarnings：告诉编译器忽略该段代码产生的警告；</p><p>对于开发人员来说，都是直接使用，无需进行其他操作</p><h4 id="1-2-2-class文件使用到注解"><a href="#1-2-2-class文件使用到注解" class="headerlink" title="1.2.2.class文件使用到注解"></a>1.2.2.class文件使用到注解</h4><p>需要通过工具对.class字节码文件进行修改的一些注解，某些工具会在类加载的时候，动态修改用某注解标注的.class文件，从而实现一些特殊的功能，一次性处理完成后，并不会存在于内存中，都是非常底层的工具库、框架会使用，对于开发人员来说，一般不会涉及到。</p><h4 id="1-2-3运行期读取的注解"><a href="#1-2-3运行期读取的注解" class="headerlink" title="1.2.3运行期读取的注解"></a>1.2.3运行期读取的注解</h4><p>一直存在于JVM中，在运行期间可以读取的注解，也是最常用的注解，如Spring的@Controller，@Service，@Repository，@AutoWired，Mybatis的@Mapper，Junit的@Test等，这类注解很多都是工具框架自定义在运行期间发挥特殊作用的注解，一般开发人员也可以自定义这类注解。</p><h2 id="2-自定义注解："><a href="#2-自定义注解：" class="headerlink" title="2.自定义注解："></a>2.自定义注解：</h2><h3 id="2-1格式："><a href="#2-1格式：" class="headerlink" title="2.1格式："></a>2.1格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123;</span><br><span class="line">  <span class="comment">//属性列表：</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2本质："><a href="#2-2本质：" class="headerlink" title="2.2本质："></a>2.2本质：</h3><p>注解的本质就是一个接口，该接口默认继承java.lang.annotation.Annotation</p><p>public interface myAnnotation extends java.lang.annotation.Annotation {<br>}</p><h3 id="2-3属性"><a href="#2-3属性" class="headerlink" title="2.3属性"></a>2.3属性</h3><p>接口中可以自定的成员方法 === 抽象方法</p><p>返回类型要求： 不能是包装类型</p><ol><li>8种基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ol><p>要求：</p><ol><li><p>定义了属性，在使用时需要给属性赋值 （可以设置默认值） String name() default “”;</p></li><li><p>特殊的属性 只有一个属性需要赋值，且属性的名字的是value 书写注解的时候可以省略vlaue=</p><blockquote><p>@myAnnotation(name = “辉”) ==&gt; @myAnnotation(“辉”)</p></blockquote></li><li><p>数组赋值的时候，使用{}包裹。如果数组中只有一个值，则{}省略</p></li></ol><p>注解样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> myAnnotation &#123;</span><br><span class="line">    <span class="comment">// 下面代表一个个的属性  default代表默认</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">myAnno2 <span class="title">ANNO_2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span>[] Arr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@myAnnotation</span>(value = <span class="string">"xx"</span>, age = <span class="number">11</span>, p = Person.p1, ANNO_2 = <span class="meta">@myAnno</span>2, Arr = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">woker</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4元注解"><a href="#2-4元注解" class="headerlink" title="2.4元注解"></a>2.4元注解</h3><p>定义： 用于描述注解的注解 元注解也可以描述元注解</p><p>@Target： 描述注解能够作用的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) <span class="comment">// 只能作用于类</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD) <span class="comment">// 只能作用于方法</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD) <span class="comment">// 只能作用于字段</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;) <span class="comment">// 作用于多个</span></span><br><span class="line"><span class="comment">//.....other</span></span><br></pre></td></tr></table></figure><p>@Retention：描述注解被保留的阶段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【默认策略】，在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 始终不会丢弃，可以使用反射获得该注解的信息。自定义的注解最常用的使用方式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Documented：描述注解是否会被抽取到文档中</p><p>表示是否将此注解的相关信息添加到javadoc文档中</p><p>@Inherited：描述注解是否被子类继承</p><p>定义该注解和子类的关系，使用此注解声明出来的自定义注解，在使用在类上面时，子类会自动继承此注解，否则，子类不会继承此注解。注意，使用@Inherited声明出来的注解，只有在类上使用时才会有效，对方法，属性等其他无效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "man"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Person</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类也拥有@Person注解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5定义注解小结"><a href="#2-5定义注解小结" class="headerlink" title="2.5定义注解小结"></a>2.5定义注解小结</h3><p>用@interface定义注解</p><p>可以添加多个参数，核心参数按约定用value，为每个参数可以设置默认值，参数类型包括基本类型、String和枚举</p><p>可以使用元注解来修饰注解，元注解包括多个，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>。</p><h2 id="3-Annotation解析处理"><a href="#3-Annotation解析处理" class="headerlink" title="3.Annotation解析处理"></a>3.Annotation解析处理</h2><h3 id="3-1解析处理"><a href="#3-1解析处理" class="headerlink" title="3.1解析处理"></a>3.1解析处理</h3><p>含注解的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Colum</span>(<span class="string">"辉"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Colum</span>(<span class="string">"18"</span>)</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">  List&lt;String&gt; colums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 获取目标类的字节码</span></span><br><span class="line">  Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.demo.Annotation.User"</span>);</span><br><span class="line">  <span class="comment">// 获取该类中所有字段</span></span><br><span class="line">  Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="comment">// 获取类中每一个字段的Colum注解</span></span><br><span class="line">    Colum col = field.getAnnotation(Colum.class);</span><br><span class="line">    <span class="comment">// 或者可以先判断有无该注解</span></span><br><span class="line">    field.isAnnotationPresent(Colum.class);</span><br><span class="line">    <span class="comment">// 添加进集合</span></span><br><span class="line">    colums.add(col.value());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印集合</span></span><br><span class="line">  colums.forEach((name) -&gt; System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们有一些常见的应用场景，需要把网站上的列表导出成excel表格，我们通过注解的方式把列名配置好，再通过反射读取实体需要导出（是否需要导出，也可通过注解配置）的每个字段的值，从而实现 excel导出的组件。</p><h3 id="3-2注解底层原理"><a href="#3-2注解底层原理" class="headerlink" title="3.2注解底层原理"></a>3.2注解底层原理</h3><p>注解定义后也是一种class，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Colum &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其实只要在类上、方法上、字段上声明注解后</strong></p><p><strong>就会根据注解上写的相关的value值生成一个.class</strong></p><p>上面注解生成一个 注解接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColumImpl</span> <span class="keyword">implements</span> <span class="title">Colum</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"声明注解时填写的内容"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"声明注解时填写的内容"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后 获取注解接口实现类实例对象 col</span></span><br><span class="line">Colum col = field.getAnnotation(Colum.class);</span><br><span class="line"><span class="comment">// 然后就可以通过对象储存的值 和 强大的反射 进行一系列操作了</span></span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本文只是抛砖引玉地讲解了注解的基本概念，注解的作用，几种元注解的功用以及使用方法，并通过一个简单的例子讲解了一下注解的处理，并不全面，文中通过Field讲解了注解的基本Api，但注解还可以修饰类、构造器、方法等，也有相对应的注解处理方法，大家可自行查一下API手册相关内容，大同小异，有不对之处，请批评指正，望共同进步，谢谢！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;注释：用文字描述程序，给程序员看的&lt;/p&gt;&lt;p&gt;注解：给机器看的&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://letcoder.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制深入学习</title>
    <link href="https://letcoder.cn/2019/09/30/Java-reflex/"/>
    <id>https://letcoder.cn/2019/09/30/Java-reflex/</id>
    <published>2019-09-30T11:29:07.000Z</published>
    <updated>2019-12-15T06:41:54.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p><strong>反射是框架设计的灵魂（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）</strong></p><a id="more"></a><h3 id="一、反射的概述"><a href="#一、反射的概述" class="headerlink" title="一、反射的概述"></a>一、反射的概述</h3><p>Java反射机制是在运行状态中，对于任意一个类(class文件)，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是<strong>Class类</strong>中的方法。所以先要获取到每一个字节码文件对应的Class类型的对象。</p><p>反射就是把java类中的各种成分映射成一个个的Java对象。例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把一个个组成部分映射成一个个对象。</p><p>（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）。</p><p><strong>以上的总结就是什么是反射</strong></p><p><br></p><p>如图是类的正常加载过程：反射的原理在与class对象。</p><p>熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p><h3 id="二、获取字节码对象的三种方式。"><a href="#二、获取字节码对象的三种方式。" class="headerlink" title="二、获取字节码对象的三种方式。"></a>二、获取字节码对象的三种方式。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class class1 = Class.forName(<span class="string">"cn.coder.Person"</span>);　<span class="comment">// 常用的</span></span><br><span class="line"><span class="comment">//通过Class类中的静态方法forName，直接获取到一个类的字节码文件对象，此时该类还是源文件阶段，并没有变为字节码文件。</span></span><br><span class="line"></span><br><span class="line">Class class2 = Person.class;</span><br><span class="line"><span class="comment">//当类被加载成.class文件时，此时Person类变成了.class，在获取该字节码文件对象，也就是获取自己， 该类处于字节码阶段。</span></span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Preson();</span><br><span class="line">Class class3 = person.getClass();　</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类的实例获取该类的字节码文件对象，该类处于创建对象阶段</span></span><br></pre></td></tr></table></figure><p>有了字节码文件对象才能获得类中所有的信息，我们在使用反射获取信息时，也要考虑使用上面哪种方式获取字节码对象合理，视不同情况而定。</p><h3 id="三、优雅的利用字节码对象"><a href="#三、优雅的利用字节码对象" class="headerlink" title="三、优雅的利用字节码对象"></a>三、优雅的利用字节码对象</h3><p>下面通过一个实例介绍Class类的功能</p><h4 id="3-1通过字节码对象获取构造器实例对象"><a href="#3-1通过字节码对象获取构造器实例对象" class="headerlink" title="3.1通过字节码对象获取构造器实例对象"></a>3.1通过字节码对象获取构造器实例对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">Class class1 = Class.forName(<span class="string">"cn.coder.Person"</span>);</span><br><span class="line">Person p1 = (Person)class1.newInstance(); <span class="comment">// 通过无参构造器 创建Person实例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局限：</span></span><br><span class="line"><span class="comment">该类无参的构造方法来是使用该Class类的newInstance()方法来创建对象的, 如果一个类没有无参的构造函数, 就不能这样创建了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">Class class2 = Class.forName(<span class="string">"cn.coder.Person"</span>);</span><br><span class="line">Construnctor con = class2.getConstructor(<span class="keyword">int</span>.class, String.class);</span><br><span class="line">Construnctor con0 = class2.getConstructor(<span class="keyword">new</span> Class[] &#123;<span class="keyword">int</span>.class, String.class&#125;); <span class="comment">//效果同上</span></span><br><span class="line">Person p2 = (Person)con.newInstance(<span class="number">18</span>,<span class="string">"臭弟弟"</span>);</span><br><span class="line">Person p0 = (Person)con0.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">18</span>, <span class="string">"臭弟弟"</span>&#125;); <span class="comment">// 效果同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种   其实还可以  获取所有构造器</span></span><br><span class="line">Constructor[] con = class2.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;con.length; i++)&#123;</span><br><span class="line">  <span class="comment">//获取每个构造函数中的参数类型字节码对象</span></span><br><span class="line">  Class[] parameterTypes = con[i].getParameterTypes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;paraparameterTypes.length; j++)&#123;</span><br><span class="line">    <span class="comment">//获取每个构造函数中的参数类型</span></span><br><span class="line">    System.out.print(paraparameterTypes[j].getName() + <span class="string">","</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2获取成员变量并使用—Filed对象"><a href="#3-2获取成员变量并使用—Filed对象" class="headerlink" title="3.2获取成员变量并使用—Filed对象"></a>3.2获取成员变量并使用—Filed对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类变量</span></span><br><span class="line">Field[] fields = personClass.getFields(); <span class="comment">// 只能获取public修饰的变量</span></span><br><span class="line">Field[] fields1 =personClass.getDeclaredFields(); <span class="comment">// 获取所有变量</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">Field a = personClass.getField(<span class="string">"a"</span>);  <span class="comment">// 获取名为a的变量</span></span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Object value = a.get(p); <span class="comment">// 获取p对象中a的值</span></span><br><span class="line">a.set(p, <span class="string">"111"</span>); <span class="comment">// 设置p对象中a的值</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">Field d = personClass.getDeclaredField(<span class="string">"d"</span>);</span><br><span class="line"><span class="comment">// 假设d是private的  则不能get  set</span></span><br><span class="line"><span class="comment">// 那么要开启set  get权限  如下语句开启</span></span><br><span class="line">d.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-3获得方法并使用-Method"><a href="#3-3获得方法并使用-Method" class="headerlink" title="3.3获得方法并使用 Method"></a>3.3获得方法并使用 Method</h4><p><strong>和上面类似 Fileld相似的</strong></p><p>可以通过Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法可以获取类中的指定方法或者所有方法，获取后可进行遍历。如果为私有方法，则需要打开一个权限。setAccessible(true); 用invoke(Object, Object…)可以调用该方法，跟上面同理，也能一次性获得所有的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class p2 = Class.forName(<span class="string">"com.demo.Reflect.Person"</span>); <span class="comment">// 创建字节码对象</span></span><br><span class="line">Person person = (Person) p2.newInstance(); <span class="comment">// 通过字节码实例一个对象</span></span><br><span class="line"></span><br><span class="line">Method[] method2 = p2.getDeclaredMethods(); <span class="comment">// 获取所有method数组</span></span><br><span class="line"><span class="keyword">for</span> (Method method : method2) &#123;</span><br><span class="line">  method.setAccessible(<span class="keyword">true</span>); <span class="comment">// 开启权限</span></span><br><span class="line">  System.out.println(method.getName());</span><br><span class="line">  <span class="comment">// 获取对象的参数 并遍历打印</span></span><br><span class="line">  Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">    System.out.print(parameterTypes[i].getName() + <span class="string">","</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 通过invoke(实例对象, 参数....)</span></span><br><span class="line">  method.invoke(person, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4获得该类的所有接口"><a href="#3-4获得该类的所有接口" class="headerlink" title="3.4获得该类的所有接口"></a>3.4获得该类的所有接口</h4><p>Class[] getInterfaces()：确定此字节码对象所表示的类或接口实现的接口</p><p>返回值：<strong>接口的字节码文件对象的数组</strong></p><h4 id="3-5获取指定资源的输入流"><a href="#3-5获取指定资源的输入流" class="headerlink" title="3.5获取指定资源的输入流"></a>3.5获取指定资源的输入流</h4><p>InputStream getResourceAsStream(String name)</p><p>return：一个 InputStream 对象；如果找不到带有该名称的资源，则返回 null</p><p>参数：所需资源的名称，如果以”/“开始，则绝对资源名为”/“后面的一部分。</p><h4 id="四、一个整体的实例"><a href="#四、一个整体的实例" class="headerlink" title="四、一个整体的实例"></a>四、一个整体的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.zhangsanfeng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">copy</span><span class="params">(Object object)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//通过传入的Object得到该实例对应的类的Class对象</span></span><br><span class="line">    Class&lt;?&gt; classType = object.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Class得到该类的Constructor对象</span></span><br><span class="line">    Constructor&lt;?&gt; cons = classType.getConstructor(<span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过反射机制使用构造方法得到一个对象，用来接受复制的内容</span></span><br><span class="line">    Object retObject = cons.newInstance(<span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取到实例对应的类的所有成员变量</span></span><br><span class="line">    Field[] fields = classType.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Field field:fields)&#123;</span><br><span class="line">      String nameOfField = field.getName();</span><br><span class="line">      <span class="comment">/*组装成员变量的get、set方法*/</span></span><br><span class="line">      String fristWord = nameOfField.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase();</span><br><span class="line">      String getMethodName = <span class="string">"get"</span>+fristWord+nameOfField.substring(<span class="number">1</span>);</span><br><span class="line">      String setMethodName = <span class="string">"set"</span>+fristWord+nameOfField.substring(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//通过反射创建类中方法的对象</span></span><br><span class="line">      Method getMethod = classType.getMethod(getMethodName, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">      Method setMethod = classType.getMethod(setMethodName, <span class="keyword">new</span> Class[]&#123;field.getType()&#125;);</span><br><span class="line">      <span class="comment">/*使用get方法从传入对象取值，使用set方法将取出的值赋给等待复制的retObject*/</span></span><br><span class="line">      Object value = getMethod.invoke(object, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">      setMethod.invoke(retObject, <span class="keyword">new</span> Object[]&#123;value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用反射创建一个person实例</span></span><br><span class="line">    Class&lt;?&gt; classType = Person.class;</span><br><span class="line">    Constructor cons = classType.getConstructor(<span class="keyword">new</span> Class[]&#123;String.class,<span class="keyword">int</span>.class,<span class="keyword">double</span>.class&#125;);</span><br><span class="line">    <span class="comment">//使用带参数的构造方法创建对象</span></span><br><span class="line">    Object perOfLee = cons.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">"Lee"</span>,<span class="number">25</span>,<span class="number">8000</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用反射调用copy方法</span></span><br><span class="line">    Class &lt;?&gt; classOfReflect = Class.forName(<span class="string">"me.zhangsanfeng.Reflection"</span>);</span><br><span class="line">    Object reflect = classOfReflect.newInstance();</span><br><span class="line">    Method methodOfCopy = classOfReflect.getMethod(<span class="string">"copy"</span>, <span class="keyword">new</span> Class[]&#123;Object.class&#125;);</span><br><span class="line">    Object finalObject = methodOfCopy.invoke(reflect, perOfLee);</span><br><span class="line">    Person copyPerson = (Person)finalObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print</span></span><br><span class="line">    System.out.println(copyPerson.getName()+<span class="string">", "</span>+copyPerson.getAge()+<span class="string">", "</span>+copyPerson.getSalary());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个“人”类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;反射是框架设计的灵魂（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java底层" scheme="https://letcoder.cn/categories/Java%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于同步异步与阻塞非阻塞的理解</title>
    <link href="https://letcoder.cn/2019/09/29/%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://letcoder.cn/2019/09/29/关于同步异步与阻塞非阻塞的理解/</id>
    <published>2019-09-29T10:20:21.000Z</published>
    <updated>2019-09-29T11:10:26.129Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。</p><a id="more"></a><h3 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1.同步与异步"></a>1.同步与异步</h3><p><strong>同步和异步</strong> 关注的是<strong>消息通信机制</strong>(synchronous communication/ asynchronous communication)</p><p><strong>所谓同步</strong>，就是在发出一个调用时，在没有得到结果之前，该调用持续等待就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。</p><p><strong>而异步则是相反</strong>，调用在发出之后，这个调用就直接返回了，但是没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><h4 id="1-1-举个通俗的例子："><a href="#1-1-举个通俗的例子：" class="headerlink" title="1.1.举个通俗的例子："></a>1.1.举个通俗的例子：</h4><p>你打电话问书店老板有没有《分布式系统》这本书。</p><p>如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p><p><br></p><h3 id="2-阻塞与非阻塞"><a href="#2-阻塞与非阻塞" class="headerlink" title="2.阻塞与非阻塞"></a>2.阻塞与非阻塞</h3><p><strong>阻塞和非阻塞</strong>关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong> (状态划重点)</p><p><strong>阻塞调用</strong>是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br><strong>非阻塞调用</strong>是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><h4 id="2-1-还是上面的例子"><a href="#2-1-还是上面的例子" class="headerlink" title="2.1.还是上面的例子"></a>2.1.还是上面的例子</h4><p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p><p><br></p><h3 id="3-再举个详细的例子"><a href="#3-再举个详细的例子" class="headerlink" title="3.再举个详细的例子"></a>3.再举个详细的例子</h3><p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span> <span class="string">老张把水壶放到火上，立等水开。（同步阻塞）</span></span><br><span class="line"><span class="attr">老张觉得自己有点傻.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2</span> <span class="string">老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</span></span><br><span class="line"><span class="attr">老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3</span> <span class="string">老张把响水壶放到火上，立等响水壶鸣笛。（异步阻塞）</span></span><br><span class="line"><span class="attr">老张觉得这样傻等意义不大</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4</span> <span class="string">老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</span></span><br><span class="line"><span class="attr">老张觉得自己聪明了。</span></span><br></pre></td></tr></table></figure><p><strong>所谓同步异步，只是对于水壶而言。</strong><br>普通水壶，同步； 响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张看电视效率的低下。</p><p><strong>所谓阻塞非阻塞，仅仅对于老张而言。</strong><br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然情况3中响水壶是异步的，可对于阻塞立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p><blockquote><p>——例子来源网络，作者不明。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。&lt;/p&gt;
    
    </summary>
    
      <category term="Java底层" scheme="https://letcoder.cn/categories/Java%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>什么是IOC和AOP</title>
    <link href="https://letcoder.cn/2019/09/26/IOC-AOP/"/>
    <id>https://letcoder.cn/2019/09/26/IOC-AOP/</id>
    <published>2019-09-26T02:33:06.000Z</published>
    <updated>2019-12-15T06:35:24.406Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC（Inversion Of Controll，控制反转）是一种设计思想，将原本在程序中手动创建对象的控制权，交由给Spring框架来管理。IOC容器是Spring用来实现IOC的载体，IOC容器实际上就是一个Map(key, value)，Map中存放的是各种对象。</p><p>这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。IOC容器就像是一个工厂，当需要创建一个对象，只需要配置好配置文件/注解即可，不用考虑对象是如何被创建出来的，大大增加了项目的可维护性且降低了开发难度。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量，提高了系统的扩展性。</p><p>Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。</p><h3 id="Spring-AOP-AspectJ-AOP-的区别？"><a href="#Spring-AOP-AspectJ-AOP-的区别？" class="headerlink" title="Spring AOP / AspectJ AOP 的区别？"></a>Spring AOP / AspectJ AOP 的区别？</h3><p>Spring AOP属于运行时增强，而AspectJ是编译时增强。</p><p>Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。</p><p>AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC&quot;&gt;&lt;/a&gt;IOC&lt;/h3&gt;&lt;p&gt;I
      
    
    </summary>
    
      <category term="Java后端" scheme="https://letcoder.cn/categories/Java%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Servlet生命周期</title>
    <link href="https://letcoder.cn/2019/09/19/servlet-declaration/"/>
    <id>https://letcoder.cn/2019/09/19/servlet-declaration/</id>
    <published>2019-09-19T14:08:42.000Z</published>
    <updated>2019-12-15T06:35:03.651Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><p>综上：</p><p>Servlet生命周期分为三个阶段：</p><ol><li>初始化阶段 调用init()方法, 只执行一次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--默认情况下，第一次被访问时，Servlet被创建，然后执行init方法；</span><br><span class="line"></span><br><span class="line">--可以配置执行Servlet的创建时机；</span><br><span class="line"></span><br><span class="line">--可以配置执行Servlet的创建时机；</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><p>响应客户请求阶段 调用service()方法 处理doGet和doPost方法，执行多次</p></li><li><p>终止阶段　当Servlet服务器正常关闭时，执行destroy方法，只执行一次</p></li></ol><p><br></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//servlet生命周期，的三个方法，</span></span><br><span class="line"><span class="comment">//1.被创建，执行且只执行一次init方法，</span></span><br><span class="line"><span class="comment">//2.提供服务，执行service方法，执行多次 </span></span><br><span class="line"><span class="comment">//3.被销毁，当Servlet服务器正常关闭时，执行destroy方法，只执行一次。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">super</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">super</span>.service(req, resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">super</span>.destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;生命周期：&lt;/strong&gt; &lt;strong&gt;Web容器加载Servlet并将其实例化后，Servlet生命周期开始&lt;/stro
      
    
    </summary>
    
      <category term="Java后端" scheme="https://letcoder.cn/categories/Java%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型学习</title>
    <link href="https://letcoder.cn/2019/09/17/Java%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://letcoder.cn/2019/09/17/Java泛型学习/</id>
    <published>2019-09-17T11:28:14.000Z</published>
    <updated>2019-10-07T13:30:43.172Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><a id="more"></a><h2 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h2><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用泛型： 即什么时候确定泛型。<strong>在创建对象的时候确定泛型</strong></p><p>例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p></li></ol><p>此时，变量E的值就是String类型了, 那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>2.举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line"><span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    </span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">"大胡子登登"</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);     </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">"aaa"</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p><strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection<object>list = new ArrayList<string>();这种是错误的。</string></object></p></blockquote><p><br></p><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>#</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。&lt;/p&gt;&lt;p&gt;泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。&lt;/p&gt;
    
    </summary>
    
      <category term="Java底层" scheme="https://letcoder.cn/categories/Java%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的堆区、栈区、方法区</title>
    <link href="https://letcoder.cn/2019/09/15/java-memory-model/"/>
    <id>https://letcoder.cn/2019/09/15/java-memory-model/</id>
    <published>2019-09-15T12:33:09.000Z</published>
    <updated>2019-12-15T06:36:56.099Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</p><p><br></p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区:"></a>栈区:</h3><ol><li><strong>每个线程包含一个栈区</strong>，栈中只保存方法中（不包括对象的成员变量）的<strong>基础数据类型和自定义对象的引用(不是对象)</strong>，对象都存放在堆区中</li><li>每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。</li><li>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)</li></ol><p><br><br></p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区:"></a>堆区:</h3><ol><li>存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。</li><li><strong>jvm只有一个堆区(heap)被所有线程共享</strong>，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的<strong>对象实例和数组</strong>都在堆中分配。</li></ol><p><br><br></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区:"></a>方法区:</h3><ol><li>又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3 id=&quot;栈区&quot;
      
    
    </summary>
    
      <category term="Java底层" scheme="https://letcoder.cn/categories/Java%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>centos修改mysql root账户密码</title>
    <link href="https://letcoder.cn/2019/09/05/centos%E4%BF%AE%E6%94%B9mysql-root%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81/"/>
    <id>https://letcoder.cn/2019/09/05/centos修改mysql-root账户密码/</id>
    <published>2019-09-05T12:04:29.000Z</published>
    <updated>2019-09-05T12:18:20.325Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><h3 id="第一步修改my-cnf文件"><a href="#第一步修改my-cnf文件" class="headerlink" title="第一步修改my.cnf文件"></a>第一步修改my.cnf文件</h3><ol><li><p>vim /etc/my.cnf</p></li><li><p>在[mysqld]中添加 skip-grant-tables</p></li></ol><p>例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="meta">skip-grant-tables</span> <span class="string"># 添加这行</span></span><br><span class="line"><span class="comment"># skip-grant-tables=1</span></span><br><span class="line"><span class="attr">datadir</span>=<span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">socket</span>=<span class="string">/var/lib/mysql/mysql.sock</span></span><br></pre></td></tr></table></figure><p>重启mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p><br></p><h3 id="第二步用户无密码登录"><a href="#第二步用户无密码登录" class="headerlink" title="第二步用户无密码登录"></a>第二步用户无密码登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p (直接点击回车，密码为空)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="第三步选择数据库修改root密码"><a href="#第三步选择数据库修改root密码" class="headerlink" title="第三步选择数据库修改root密码"></a>第三步选择数据库修改root密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update mysql.user set authentication_string=password(&apos;新密码&apos;) where User=&apos;用户&apos;;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="第四步刷新并退出"><a href="#第四步刷新并退出" class="headerlink" title="第四步刷新并退出"></a>第四步刷新并退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="第五步编辑my-cnf并重启mysql"><a href="#第五步编辑my-cnf并重启mysql" class="headerlink" title="第五步编辑my.cnf并重启mysql"></a>第五步编辑my.cnf并重启mysql</h3><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 删除 skip-grant-tables  保存退出</span></span><br><span class="line">service mysql restart  <span class="comment"># 重启mysql</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://www.jb51.net/article/100211.htm" target="_blank" rel="noopener">文章1</a></li><li><a href="https://www.cnblogs.com/jekaysnow/p/8849533.html" target="_blank" rel="noopener">文章2</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;第一步修改my-cnf文件&quot;&gt;&lt;a href=&quot;#第一步修改my-cnf文件&quot; class=&quot;headerlink&quot; title=&quot;第
      
    
    </summary>
    
      <category term="Mysql" scheme="https://letcoder.cn/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://letcoder.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql忘记密码解决方案</title>
    <link href="https://letcoder.cn/2019/09/04/forget-mysql-password/"/>
    <id>https://letcoder.cn/2019/09/04/forget-mysql-password/</id>
    <published>2019-09-04T13:02:38.000Z</published>
    <updated>2019-12-15T06:32:40.726Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>Mysql 忘记了密码 解决方案：</p><p><br></p><ol><li>Cmd – &gt; 停止mysql服务 （以管理员的身份） net stop mysql;</li><li>使用无验证方式启动mysql mysqld –skip-grant-tables</li><li>打开新的cmd窗口，直接输入mysql 回车 登录成功</li><li>依次执行 use mysql; set password for “root”@”localhost” = password(“新密码”);</li><li>手动执行mysqld的进程</li><li>启动mysql服务 net start mysql;</li><li>使用新密码登录</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Mysql 忘记了密码 解决方案：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Cmd – &amp;gt; 停止mysql服务 （以管理员的身份） n
      
    
    </summary>
    
      <category term="Mysql" scheme="https://letcoder.cn/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://letcoder.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>springMVC配置定时任务</title>
    <link href="https://letcoder.cn/2019/08/24/springMVC%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>https://letcoder.cn/2019/08/24/springMVC配置定时任务/</id>
    <published>2019-08-24T13:31:22.000Z</published>
    <updated>2019-12-14T14:22:12.938Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><h2 id="springMVC配置定时执行任务"><a href="#springMVC配置定时执行任务" class="headerlink" title="springMVC配置定时执行任务"></a>springMVC配置定时执行任务</h2><h3 id="配置xml"><a href="#配置xml" class="headerlink" title="配置xml"></a>配置xml</h3><p>在SpringMVC配置文件中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task" </span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/task  </span><br><span class="line">http://www.springframework.org/schema/task/spring-task-4.3.xsd</span><br></pre></td></tr></table></figure><p>配置任务扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:annotation-driven /&gt;</span><br></pre></td></tr></table></figure><p>配置扫描任务位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描任务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.xxx.task"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://iqxqzx.gitee.io/pic/images/2019/8/24/1.png" alt="img"></p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kaoqin.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ? "</span>) <span class="comment">// 间隔5秒执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用SpringMVC框架配置定时任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>1、spring的 @Scheduled 注解 需要写在实现方法上</p><p>2、 定时器的任务方法不能有返回值（如果有返回值，spring初始化的时候会告诉你有个错误、需要设定一个proxytargetclass的某个值为true）</p><p>3、实现类上要有组件的注解@Component</p><p><strong>扩展：定时时间的设置</strong></p><p>如：“0/5 <em></em> <em></em> ?”</p><p>CronTrigger配置完整格式为： [秒] [分] [小时] [日] [月] [周] [年]</p><table><thead><tr><th>序号</th><th>说明</th><th>是否必填</th><th>允许填写的值</th><th>允许的通配符</th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>是</td><td>0-59</td><td>, - * /</td></tr><tr><td>2</td><td>分</td><td>是</td><td>0-59</td><td>, - * /</td></tr><tr><td>3</td><td>小时</td><td>是</td><td>0-23</td><td>, - * /</td></tr><tr><td>4</td><td>日</td><td>是</td><td>1-31</td><td>, - * ? / L W</td></tr><tr><td>5</td><td>月</td><td>是</td><td>1-12或JAN-DEC</td><td>, - * /</td></tr><tr><td>6</td><td>周</td><td>是</td><td>1-7或SUN-SAT</td><td>, - * ? / L W</td></tr><tr><td>7</td><td>年</td><td>否</td><td>empty 或1970-2099</td><td>, - * /</td></tr></tbody></table><p>通配符说明:</p><p>* 表示所有值. 例如:在分的字段上设置 “*”,表示每一分钟都会触发。</p><p>? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。</p><p>例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?</p><p>- 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。</p><p>, 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</p><p>/ 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。</p><p>L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”</p><p>W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“).</p><p># 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；</p><p><strong>小提示：</strong><br>‘L’和 ‘W’可以组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；<br>周字段的设置，若使用英文字母是不区分大小写的，即MON 与mon相同；</p><p>参考：</p><p><a href="https://wuzhuti.cn/850.html/comment-page-1/" target="_blank" rel="noopener">https://wuzhuti.cn/850.html/comment-page-1/</a></p><p><a href="https://wuzhuti.cn/447.html" target="_blank" rel="noopener">https://wuzhuti.cn/447.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;springMVC配置定时执行任务&quot;&gt;&lt;a href=&quot;#springMVC配置定时执行任务&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Java后端" scheme="https://letcoder.cn/categories/Java%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>表单onsubmit事件无效&amp;表单onsubmit后使用ajax无效解决</title>
    <link href="https://letcoder.cn/2019/08/17/onsubmit-ajax-error/"/>
    <id>https://letcoder.cn/2019/08/17/onsubmit-ajax-error/</id>
    <published>2019-08-17T12:02:47.000Z</published>
    <updated>2019-12-15T06:31:32.948Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>这段时间在写一个h5+app，用于一个组队比赛项目的app。由于自身也没有多少前端开发的经验，也就是闷着头一直乱写，在开发中也遇到了各种难题。</p><p>今天又解决一发问题，(此处需要掌声)， 成就感！</p><h3 id="关于登录表单submit的问题"><a href="#关于登录表单submit的问题" class="headerlink" title="关于登录表单submit的问题"></a>关于登录表单submit的问题</h3><p>这个过程需要用到的技术主要就是ajax技术和js的onsubmit技术。</p><p>过程如下：</p><blockquote><p>1.用户输入 用户名和密码</p><p>2.当用户点击提交按钮时，利用ajax请求后端接口 进行用户名密码验证。</p></blockquote><p>但是这时候出现一个问题，就是当 用户点击输入法的 <strong>发送</strong> <strong>提交</strong> 按钮的时候，我们怎么验证</p><p>这时候就需要原生js的 onsubmit 方法了</p><blockquote><p>3.1 验证不通过，onsubmit返回false，表单无法提交，页面提示用户密码有错。</p><p>3.2 验证通过，onsubmit返回true，表单提交，服务器返回用户内部视图，登陆成功。</p></blockquote><p>废话不说上代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击手机键盘  提交按钮</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"login"</span>).onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  subData();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 点击登录按钮</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"login-btn"</span>).addEventListener(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  subData();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取表单数据</span></span><br><span class="line">  <span class="keyword">var</span> data = getFormData(<span class="string">"login"</span>);</span><br><span class="line">  </span><br><span class="line">  mui.ajax(<span class="string">'http://192.168.1.142:8080/user/login.do'</span>, &#123;</span><br><span class="line">    data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="string">'username'</span>: data.username,</span><br><span class="line">      <span class="string">'password'</span>: data.password</span><br><span class="line">    &#125;),</span><br><span class="line">    dataType: <span class="string">'json'</span>, <span class="comment">//服务器返回json格式数据</span></span><br><span class="line">    type: <span class="string">'post'</span>, <span class="comment">//HTTP请求类型</span></span><br><span class="line">    timeout: <span class="number">10000</span>, <span class="comment">//超时时间设置为10秒；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  async: false, // 同步方式是为了解决   手机键盘提交按钮 提交表单验证bug的</span></span><br><span class="line">    </span><br><span class="line">    contentType: <span class="string">'application/json;charset=utf-8'</span>, <span class="comment">// 少了会报错</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">      <span class="keyword">if</span> (data.status == <span class="number">200</span>) &#123;</span><br><span class="line">        mui.toast(<span class="string">"登录成功"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.status == <span class="number">-200</span>) &#123;</span><br><span class="line">        mui.toast(<span class="string">"登录失败，请重新登录"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, type, errorThrown</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果用上面的代码，点击手机键盘 提交按钮 是无法完成验证操作的、</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>上面代码用的是 异步的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">checkpwd</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//1............</span></span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//2........</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="comment">//3.........</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><p>如果是同步方式：当1执行完毕后，接着执行ajax，线程会处于等待状态，等2执行完毕之后，接着执行3.</p></li><li><p>如果是异步方式：当1执行完毕之后，接着执行ajax，但是ajax不会阻塞主线程，ajax执行的同时会执行3.</p></li></ul><p><br></p><p>下面展示错误的ajax验证方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击手机键盘  提交按钮</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"login"</span>).onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1........</span></span><br><span class="line">  </span><br><span class="line">  mui.ajax(<span class="string">'http://192.168.1.142:8080/user/login.do'</span>, &#123;</span><br><span class="line">    <span class="comment">// 2.......</span></span><br><span class="line">    data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="string">'username'</span>: data.username,</span><br><span class="line">      <span class="string">'password'</span>: data.password</span><br><span class="line">    &#125;),</span><br><span class="line">    dataType: <span class="string">'json'</span>, <span class="comment">//服务器返回json格式数据</span></span><br><span class="line">    type: <span class="string">'post'</span>, <span class="comment">//HTTP请求类型  </span></span><br><span class="line">    contentType: <span class="string">'application/json;charset=utf-8'</span>, <span class="comment">// 少了会报错</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"success"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, type, errorThrown</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3........</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>上面的代码， 先执行 1 后 执行 2 。但是2 (ajax) 不会阻塞主线程，2 (ajax) 执行的同时会执行3. 这时候3 没等验证成功，立马返回false</strong></p><p>因此，当使用异步方式进行验证的时候，会出现无论如何，onsubmit（onclick）都不会起作用，这会让程序员感觉自己的代码有问题，其实代码没问题，是逻辑的问题。要解决这个问题，我们就必须用ajax的同步方式。</p><p><br></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>改为同步方式 ajax 中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> : <span class="literal">false</span>,</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://my.oschina.net/qkmc/blog/872778" target="_blank" rel="noopener">文章1</a></li><li><a href></a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;这段时间在写一个h5+app，用于一个组队比赛项目的app。由于自身也没有多少前端开发的经验，也就是闷着头一直乱写，在开发中也遇到了各种难题。&lt;
      
    
    </summary>
    
      <category term="HTML5+APP" scheme="https://letcoder.cn/categories/HTML5-APP/"/>
    
    
      <category term="Web移动端" scheme="https://letcoder.cn/tags/Web%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis查询parameterType多参数问题</title>
    <link href="https://letcoder.cn/2019/08/15/Mybatis%E6%9F%A5%E8%AF%A2parameterType%E5%A4%9A%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>https://letcoder.cn/2019/08/15/Mybatis查询parameterType多参数问题/</id>
    <published>2019-08-15T13:32:45.000Z</published>
    <updated>2019-12-13T12:44:05.353Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><h2 id="Mybatis查询parameterType多参数问题"><a href="#Mybatis查询parameterType多参数问题" class="headerlink" title="Mybatis查询parameterType多参数问题"></a>Mybatis查询parameterType多参数问题</h2><h3 id="一、单个参数："><a href="#一、单个参数：" class="headerlink" title="一、单个参数："></a>一、单个参数：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">List&lt;EntInfo&gt; <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"findByUsername"</span> resultMap=<span class="string">"EntInfoResultMap"</span> parameterType=<span class="string">"java.lang.String"</span> &gt;</span><br><span class="line">.......</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>其中方法名和ID一致，#{} 中的参数名与方法中的参数名一致， 这里采用的是@Param这个参数，实际上@Param这个最后会被Mabatis封装为map类型的。</p><p>select 后的字段列表要和bean中的属性名一致， 如果不一致的可以用 as 来补充。</p><h3 id="二、多参数："><a href="#二、多参数：" class="headerlink" title="二、多参数："></a>二、多参数：</h3><p>方案1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;XXX&gt; <span class="title">getXXX</span><span class="params">(String xxId, String xxCode)</span></span>;  </span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"getXXX"</span> resultType=<span class="string">"XXX"</span>&gt; <span class="comment">// 不需要写parameterType参数</span></span><br><span class="line"></span><br><span class="line">　　select t.* from tableName where id = #&#123;0&#125; and name = #&#123;1&#125;  </span><br><span class="line"></span><br><span class="line">&lt;/select&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于是多参数那么就不能使用parameterType， 改用#｛index｝是第几个就用第几个的索引，索引从0开始</span></span><br></pre></td></tr></table></figure><p>方案2（推荐）基于注解</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;XXXBean&gt; <span class="title">getXXXBeanList</span><span class="params">(@Param(<span class="string">"id"</span>)</span>String id, @<span class="title">Param</span><span class="params">(<span class="string">"code"</span>)</span>String code)</span>;  </span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"getXXXBeanList"</span> resultType=<span class="string">"XXBean"</span>&gt;</span><br><span class="line"></span><br><span class="line">　　select t.* from tableName where id = #&#123;id&#125; and name = #&#123;code&#125;  </span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>由于是多参数那么就不能使用parameterType， 这里用@Param来指定哪一个。</p><h3 id="三、map封装多参数："><a href="#三、map封装多参数：" class="headerlink" title="三、map封装多参数："></a>三、map封装多参数：</h3><p>通过传入map对象查询 并返回user对象的list集合</p><p>直接通过map里面的key直接访问 #{key}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsersByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">3</span>. 通过传入map对象查询 并返回user对象的list集合  map里面的属性直接访问 --&gt;</span><br><span class="line">&lt;select id=<span class="string">"findUsersByMap"</span> parameterType=<span class="string">"hashmap"</span> resultType=<span class="string">"user"</span>&gt;</span><br><span class="line">    select * from users where sex=#&#123;sex&#125; and username =#&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h3 id="四、List封装多个参数："><a href="#四、List封装多个参数：" class="headerlink" title="四、List封装多个参数："></a>四、List封装多个参数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;XXX&gt; <span class="title">getXXX</span><span class="params">(List&lt;String&gt; list)</span></span>;  </span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"getXXXBeanList"</span> resultType=<span class="string">"XXBean"</span>&gt;</span><br><span class="line">　　select 字段... from XXX where id in</span><br><span class="line">　　&lt;foreach item=<span class="string">"item"</span> index=<span class="string">"index"</span> collection=<span class="string">"list"</span> open=<span class="string">"("</span> separator=<span class="string">","</span> close=<span class="string">")"</span>&gt;  </span><br><span class="line">　　　　#&#123;item&#125;  </span><br><span class="line">　　&lt;/foreach&gt;  </span><br><span class="line">&lt;/select&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach 最后的效果是select 字段... from XXX where id in ('1','2','3','4')</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Mybatis查询parameterType多参数问题&quot;&gt;&lt;a href=&quot;#Mybatis查询parameterType多参数问题&quot;
      
    
    </summary>
    
      <category term="Java后端" scheme="https://letcoder.cn/categories/Java%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTML5+app实现文件上传(java后端)</title>
    <link href="https://letcoder.cn/2019/08/13/HTML5-app%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-java%E5%90%8E%E7%AB%AF/"/>
    <id>https://letcoder.cn/2019/08/13/HTML5-app实现文件上传-java后端/</id>
    <published>2019-08-13T12:18:59.000Z</published>
    <updated>2019-12-15T07:09:28.166Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --><p>以拍照上传，相册选择图片上传为例</p><h3 id="HTML5-Plus-拍照或者相册选择图片上传到服务器"><a href="#HTML5-Plus-拍照或者相册选择图片上传到服务器" class="headerlink" title="HTML5 Plus 拍照或者相册选择图片上传到服务器"></a>HTML5 Plus 拍照或者相册选择图片上传到服务器</h3><p><br></p><p>起因：正在写一个人脸识别打卡签到的webApp，其中需要一个拍摄照片并上传服务器的功能</p><p>通过阅读<a href="http://www.html5plus.org/doc" target="_blank" rel="noopener">h5+官方文档</a> 了解到有相册 、相机、 文件上传等接口</p><h4 id="下面学习这几个api："><a href="#下面学习这几个api：" class="headerlink" title="下面学习这几个api："></a>下面学习这几个api：</h4><p>1、从图库选择图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">plus.gallery.pick(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;       <span class="comment">// path为选择图片的路径</span></span><br><span class="line">    <span class="comment">// 下面将图片显示在界面</span></span><br><span class="line">    hui(<span class="string">'#img3 div'</span>).hide();</span><br><span class="line">    hui(<span class="string">'#img3 img'</span>).attr(<span class="string">'src'</span>, path);</span><br><span class="line">    hui(<span class="string">'#img3 img'</span>).show();</span><br><span class="line">    <span class="comment">// 上传文件</span></span><br><span class="line">    imgUpload(path);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    hui.toast(<span class="string">"上传失败"</span>);</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    filter: <span class="string">'image'</span>,</span><br><span class="line">    system: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 选择多张图片</span></span><br><span class="line">plus.gallery.pick(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">paths</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> paths.files)&#123;</span><br><span class="line">      hui.toast(paths.files[i]);</span><br><span class="line">      <span class="comment">//imgUpload(path);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    hui.toast(<span class="string">'取消了选择'</span>);</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    filter: <span class="string">'image'</span>,</span><br><span class="line">    multiple: <span class="literal">true</span>,</span><br><span class="line">    maximum: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br></p><p>2、相机获取图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plus.camera.getCamera().captureImage(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个path 不能直接使用 是相对的  需要进行路径转换</span></span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">"file://"</span> + plus.io.convertLocalFileSystemURL(path); <span class="comment">// 路径转换</span></span><br><span class="line">    hui(<span class="string">'#img2 div'</span>).hide();</span><br><span class="line">    hui(<span class="string">'#img2 img'</span>).attr(<span class="string">'src'</span>, path);</span><br><span class="line">    hui(<span class="string">'#img2 img'</span>).show();</span><br><span class="line">    imgUpload(path);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    hui.toast(<span class="string">"上传失败"</span>);</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    index: <span class="number">2</span> <span class="comment">// 拍照时默认的摄像头 1后置 2 前置</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>3、uploader文件上传</p><p>原理应该就是通过http 的post请求上传文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片上传（java后端测试成功）</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imgUpload</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  plus.nativeUI.showWaiting();</span><br><span class="line">  <span class="keyword">var</span> task = plus.uploader.createUpload(</span><br><span class="line">    <span class="string">'http://192.168.1.142:8080/img/upload.do'</span>, &#123;</span><br><span class="line">      method: <span class="string">"POST"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">resp, status</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (status == <span class="number">200</span>) &#123;</span><br><span class="line">        plus.nativeUI.closeWaiting();</span><br><span class="line">        <span class="built_in">console</span>.log(resp.responseText);</span><br><span class="line">        mui.toast(<span class="string">'上传成功'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mui.toast(<span class="string">'上传失败'</span>);</span><br><span class="line">        plus.nativeUI.closeWaiting();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  task.addFile(path, &#123;<span class="attr">key</span>: <span class="string">'file'</span>&#125;); <span class="comment">// 这里必须和 java后端的 @RequestParam(value = "file") 对应</span></span><br><span class="line">  task.addData(<span class="string">"name"</span>, <span class="string">"test"</span>);</span><br><span class="line">  task.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是上述所写，server为上传的服务端接口地址，如果上传成功，则回调的status会返回200，不成功或者接口参数有问题会返回400或者500。</p><p>resp.responseText 服务端返回的结果，一般服务端会返回json，解析一下json就可以使用了。</p><p><br></p><p>传输其他文件时如果还想添加其他参数，用.addData(key,value),</p><p>添加图片用.addFile(图片路径，{key:后端接收文件的名字})， <strong>这个key必须和后端接收名字对应</strong></p><p>配合后端代码看会好理解，后端我用java接收的：</p><p><br></p><p>4、Java后端接收并保存</p><p>用标准的MultipartFile接收即可。注意xml限制的大小设定</p><p>springMVC.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--单位字节--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"20480000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/upload"</span>, produces = <span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadImg</span><span class="params">(@RequestParam(value = <span class="string">"file"</span>)</span> MultipartFile file, HttpServletRequest request) </span>&#123;</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String oriFilename = file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件后缀</span></span><br><span class="line">    String fileType = oriFilename.substring(oriFilename.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>, oriFilename.length()).toLowerCase();</span><br><span class="line">    <span class="comment">// 存储路径</span></span><br><span class="line">    String basePath = <span class="string">"/Users/qxqzx/Desktop/img/"</span>;</span><br><span class="line">    <span class="comment">// 保存的文件名字</span></span><br><span class="line">    String saveName = String.valueOf(<span class="keyword">new</span> Date().getTime()) + <span class="string">"."</span> + fileType;</span><br><span class="line">    File dst = <span class="keyword">new</span> File(basePath, saveName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dst.getParentFile().exists()) &#123;</span><br><span class="line">      dst.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    file.transferTo(dst); <span class="comment">// 写入本地</span></span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">    map.put(<span class="string">"code"</span>, <span class="string">"200"</span>);</span><br><span class="line">    map.put(<span class="string">"msg"</span>, <span class="string">"图片上传成功！"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    map.put(<span class="string">"success"</span>, <span class="keyword">false</span>);</span><br><span class="line">    map.put(<span class="string">"code"</span>, <span class="string">"-200"</span>);</span><br><span class="line">    map.put(<span class="string">"msg"</span>, <span class="string">"图片上传失败！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JSON.toJSONString(map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时总结到这, 等后续补充</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 15:04:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;以拍照上传，相册选择图片上传为例&lt;/p&gt;&lt;h3 id=&quot;HTML5-Plus-拍照或者相册选择图片上传到服务器&quot;&gt;&lt;a href=&quot;#HTML5
      
    
    </summary>
    
      <category term="HTML5+APP" scheme="https://letcoder.cn/categories/HTML5-APP/"/>
    
    
      <category term="Java" scheme="https://letcoder.cn/tags/Java/"/>
    
      <category term="Web前端" scheme="https://letcoder.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
