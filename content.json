{"meta":{"title":"QXQZX's blog","subtitle":null,"description":"爱生活, 爱代码, 记录生活, 记录代码","author":"QXQZX","url":"https://letcoder.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-09-15T14:04:36.739Z","updated":"2019-09-15T13:05:57.957Z","comments":true,"path":"404.html","permalink":"https://letcoder.cn/404.html","excerpt":"","text":"404 Not Found很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-09-15T13:06:29.340Z","updated":"2019-09-15T12:58:08.162Z","comments":true,"path":"about/index.html","permalink":"https://letcoder.cn/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425262728&#123; name: 'QXQZX' age: 19, gender: '男', profession: 'Student &amp; Coder', experience: '0年', address: '山东省淄博市', education: '本科在校', github: 'https://github.com/QXQZX', blog: 'https://letcoder.cn', email: '501966782@qq.com', description: '一杯水，一包烟，一个bug玩一天', skills: [ ['Html', 'JavaScript', 'jQuery', 'CSS', 'ES6', 'Node', 'Bootstrap'], ['Git', 'Linux'], ['Java', 'Spring', 'SpringMVC', 'Mybatis'], ['Mysql'], ['数据结构'] ], devTools: [ ['Sublime Text', 'Visual Studio Code', 'Hbuilder'], ['Chrome DevTools', 'Fiddler'], ['Idea', 'Eclipse'], ['Navicat', 'Terminal'], ] &#125;"},{"title":"所有分类","date":"2019-09-15T13:38:44.767Z","updated":"2019-09-15T13:38:44.767Z","comments":true,"path":"categories/index.html","permalink":"https://letcoder.cn/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-09-15T13:36:23.167Z","updated":"2019-09-15T13:36:23.167Z","comments":true,"path":"tags/index.html","permalink":"https://letcoder.cn/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-09-16T11:25:09.271Z","updated":"2019-09-16T11:25:09.271Z","comments":true,"path":"friends/index.html","permalink":"https://letcoder.cn/friends/index.html","excerpt":"","text":"这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～名称： QXQZX’s Blog头像： https://blog.zxnest.club/logo.png网址： https://blog.zxnest.club/标签： Java"},{"title":"所有分类","date":"2019-09-15T13:40:07.491Z","updated":"2019-09-15T13:40:07.491Z","comments":true,"path":"projects/index.html","permalink":"https://letcoder.cn/projects/index.html","excerpt":"","text":""}],"posts":[{"title":"Java注解学习","slug":"Java注解学习","date":"2019-10-07T13:28:44.000Z","updated":"2019-10-07T13:44:52.825Z","comments":true,"path":"2019/10/07/Java注解学习/","link":"","permalink":"https://letcoder.cn/2019/10/07/Java注解学习/","excerpt":"注释：用文字描述程序，给程序员看的注解：给机器看的","text":"注释：用文字描述程序，给程序员看的注解：给机器看的1.注解基础知识点定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。1.1作用分类：①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】②代码分析：通过代码里标识的元数据对代码进行分析【使用反射】③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查，编译检查是否是复写父类的方法【Override】给某个类、方法..添加了一个注解，这个环节仅仅是做了一个标记，对代码本身并不会造成任何影响，需要后续环节的配合，需要其他方法对该注解赋予业务逻辑处理。就如同我们在微信上发了一个共享定位，此时并没有什么用，只有当后面其他人都进入了这个共享定位，大家之间的距离才能明确，才知道该怎么聚在一起。1.2注解分为三类：1.2.1编译器使用到的注解如@Override，@SuppressWarnings都是编译器使用到的注解，作用是告诉编译器一些事情，而不会进入编译后的.class文件。@Override：告诉编译器检查一下是否重写了父类的方法；@SuppressWarnings：告诉编译器忽略该段代码产生的警告；对于开发人员来说，都是直接使用，无需进行其他操作1.2.2.class文件使用到注解需要通过工具对.class字节码文件进行修改的一些注解，某些工具会在类加载的时候，动态修改用某注解标注的.class文件，从而实现一些特殊的功能，一次性处理完成后，并不会存在于内存中，都是非常底层的工具库、框架会使用，对于开发人员来说，一般不会涉及到。1.2.3运行期读取的注解一直存在于JVM中，在运行期间可以读取的注解，也是最常用的注解，如Spring的@Controller，@Service，@Repository，@AutoWired，Mybatis的@Mapper，Junit的@Test等，这类注解很多都是工具框架自定义在运行期间发挥特殊作用的注解，一般开发人员也可以自定义这类注解。2.自定义注解：2.1格式：123public @interface 注解名称 &#123; //属性列表：&#125;2.2本质：注解的本质就是一个接口，该接口默认继承java.lang.annotation.Annotationpublic interface myAnnotation extends java.lang.annotation.Annotation {}2.3属性接口中可以自定的成员方法 === 抽象方法返回类型要求： 不能是包装类型8种基本数据类型String枚举注解以上类型的数组要求：定义了属性，在使用时需要给属性赋值 （可以设置默认值） String name() default “”;特殊的属性 只有一个属性需要赋值，且属性的名字的是value 书写注解的时候可以省略vlaue=@myAnnotation(name = “辉”) ==&gt; @myAnnotation(“辉”)数组赋值的时候，使用{}包裹。如果数组中只有一个值，则{}省略注解样例：12345678910package com.demo.Annotation;public @interface myAnnotation &#123; // 下面代表一个个的属性 default代表默认 String value() default \"\"; int age() default 0; Person p(); myAnno2 ANNO_2(); int[] Arr();&#125;使用注解：12345package com.demo.Annotation;@myAnnotation(value = \"xx\", age = 11, p = Person.p1, ANNO_2 = @myAnno2, Arr = &#123;1, 2&#125;)public class woker &#123;&#125;2.4元注解定义： 用于描述注解的注解 元注解也可以描述元注解@Target： 描述注解能够作用的位置12345@Target(ElementType.TYPE) // 只能作用于类@Target(ElementType.METHOD) // 只能作用于方法@Target(ElementType.FIELD) // 只能作用于字段@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;) // 作用于多个//.....other@Retention：描述注解被保留的阶段123456789101112131415161718192021@Retention(RetentionPolicy.RUNTIME)@Retention(RetentionPolicy.CLASS)@Retention(RetentionPolicy.SOURCE)//-------------------------------------------------------//public enum RetentionPolicy &#123; /** * 仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中. */ SOURCE, /** * 【默认策略】，在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到 */ CLASS, /** * 始终不会丢弃，可以使用反射获得该注解的信息。自定义的注解最常用的使用方式。 */ RUNTIME&#125;@Documented：描述注解是否会被抽取到文档中表示是否将此注解的相关信息添加到javadoc文档中@Inherited：描述注解是否被子类继承定义该注解和子类的关系，使用此注解声明出来的自定义注解，在使用在类上面时，子类会自动继承此注解，否则，子类不会继承此注解。注意，使用@Inherited声明出来的注解，只有在类上使用时才会有效，对方法，属性等其他无效。123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface Person &#123; String value() default \"man\";&#125;1234567@Personpublic class Parent &#123;&#125;//子类也拥有@Person注解class Son extends Parent &#123;&#125;2.5定义注解小结用@interface定义注解可以添加多个参数，核心参数按约定用value，为每个参数可以设置默认值，参数类型包括基本类型、String和枚举可以使用元注解来修饰注解，元注解包括多个，必须设置@Target和@Retention，@Retention一般设置为RUNTIME。3.Annotation解析处理3.1解析处理含注解的类12345678910111213141516171819202122232425package com.demo.Annotation;public class User &#123; @Colum(\"辉\") private String name; @Colum(\"18\") private String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125;获取注解12345678910111213141516171819@Testpublic void test02() throws ClassNotFoundException &#123; List&lt;String&gt; colums = new ArrayList&lt;&gt;(); // 获取目标类的字节码 Class&lt;?&gt; clazz = Class.forName(\"com.demo.Annotation.User\"); // 获取该类中所有字段 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; // 获取类中每一个字段的Colum注解 Colum col = field.getAnnotation(Colum.class); // 或者可以先判断有无该注解 field.isAnnotationPresent(Colum.class); // 添加进集合 colums.add(col.value()); &#125; // 打印集合 colums.forEach((name) -&gt; System.out.println(name));&#125;比如我们有一些常见的应用场景，需要把网站上的列表导出成excel表格，我们通过注解的方式把列名配置好，再通过反射读取实体需要导出（是否需要导出，也可通过注解配置）的每个字段的值，从而实现 excel导出的组件。3.2注解底层原理注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。12345678910111213package com.demo.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Colum &#123; String value() default \"\"; String name() default \"\";&#125;其实只要在类上、方法上、字段上声明注解后就会根据注解上写的相关的value值生成一个.class上面注解生成一个 注解接口的实现类12345678910111213//....public class ColumImpl implements Colum &#123; public String getValue() &#123; return \"声明注解时填写的内容\"; &#125; public String getName() &#123; return \"声明注解时填写的内容\"; &#125;&#125;// 然后 获取注解接口实现类实例对象 colColum col = field.getAnnotation(Colum.class);// 然后就可以通过对象储存的值 和 强大的反射 进行一系列操作了4.总结本文只是抛砖引玉地讲解了注解的基本概念，注解的作用，几种元注解的功用以及使用方法，并通过一个简单的例子讲解了一下注解的处理，并不全面，文中通过Field讲解了注解的基本Api，但注解还可以修饰类、构造器、方法等，也有相对应的注解处理方法，大家可自行查一下API手册相关内容，大同小异，有不对之处，请批评指正，望共同进步，谢谢！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letcoder.cn/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"Java反射机制深入学习","slug":"Java反射机制深入学习","date":"2019-09-30T11:29:07.000Z","updated":"2019-09-30T13:18:56.366Z","comments":true,"path":"2019/09/30/Java反射机制深入学习/","link":"","permalink":"https://letcoder.cn/2019/09/30/Java反射机制深入学习/","excerpt":"反射是框架设计的灵魂（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）","text":"反射是框架设计的灵魂（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）一、反射的概述Java反射机制是在运行状态中，对于任意一个类(class文件)，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法。所以先要获取到每一个字节码文件对应的Class类型的对象。反射就是把java类中的各种成分映射成一个个的Java对象。例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把一个个组成部分映射成一个个对象。（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）。以上的总结就是什么是反射如图是类的正常加载过程：反射的原理在与class对象。熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。二、获取字节码对象的三种方式。12345678910Class class1 = Class.forName(\"cn.coder.Person\"); // 常用的//通过Class类中的静态方法forName，直接获取到一个类的字节码文件对象，此时该类还是源文件阶段，并没有变为字节码文件。Class class2 = Person.class;//当类被加载成.class文件时，此时Person类变成了.class，在获取该字节码文件对象，也就是获取自己， 该类处于字节码阶段。Person person = new Preson();Class class3 = person.getClass(); //通过类的实例获取该类的字节码文件对象，该类处于创建对象阶段有了字节码文件对象才能获得类中所有的信息，我们在使用反射获取信息时，也要考虑使用上面哪种方式获取字节码对象合理，视不同情况而定。三、优雅的利用字节码对象下面通过一个实例介绍Class类的功能3.1通过字节码对象获取构造器实例对象123456789101112131415161718192021222324252627// 第一种Class class1 = Class.forName(\"cn.coder.Person\");Person p1 = (Person)class1.newInstance(); // 通过无参构造器 创建Person实例/*局限：该类无参的构造方法来是使用该Class类的newInstance()方法来创建对象的, 如果一个类没有无参的构造函数, 就不能这样创建了。*/// 第二种Class class2 = Class.forName(\"cn.coder.Person\");Construnctor con = class2.getConstructor(int.class, String.class);Construnctor con0 = class2.getConstructor(new Class[] &#123;int.class, String.class&#125;); //效果同上Person p2 = (Person)con.newInstance(18,\"臭弟弟\");Person p0 = (Person)con0.newInstance(new Object[]&#123;18, \"臭弟弟\"&#125;); // 效果同上// 第三种 其实还可以 获取所有构造器Constructor[] con = class2.getConstructors();for(int i=0; i&lt;con.length; i++)&#123; //获取每个构造函数中的参数类型字节码对象 Class[] parameterTypes = con[i].getParameterTypes(); for(int j=0; j&lt;paraparameterTypes.length; j++)&#123; //获取每个构造函数中的参数类型 System.out.print(paraparameterTypes[j].getName() + \",\"); &#125;&#125;3.2获取成员变量并使用—Filed对象123456789101112131415161718Class personClass = Person.class;// 获取类变量Field[] fields = personClass.getFields(); // 只能获取public修饰的变量Field[] fields1 =personClass.getDeclaredFields(); // 获取所有变量System.out.println(\"---------------\");Field a = personClass.getField(\"a\"); // 获取名为a的变量Person p = new Person();Object value = a.get(p); // 获取p对象中a的值a.set(p, \"111\"); // 设置p对象中a的值System.out.println(\"---------------\");Field d = personClass.getDeclaredField(\"d\");// 假设d是private的 则不能get set// 那么要开启set get权限 如下语句开启d.setAccessible(true);3.3获得方法并使用 Method和上面类似 Fileld相似的可以通过Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法可以获取类中的指定方法或者所有方法，获取后可进行遍历。如果为私有方法，则需要打开一个权限。setAccessible(true); 用invoke(Object, Object…)可以调用该方法，跟上面同理，也能一次性获得所有的方法：123456789101112131415Class p2 = Class.forName(\"com.demo.Reflect.Person\"); // 创建字节码对象Person person = (Person) p2.newInstance(); // 通过字节码实例一个对象Method[] method2 = p2.getDeclaredMethods(); // 获取所有method数组for (Method method : method2) &#123; method.setAccessible(true); // 开启权限 System.out.println(method.getName()); // 获取对象的参数 并遍历打印 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (int i = 0; i &lt; parameterTypes.length; i++) &#123; System.out.print(parameterTypes[i].getName() + \",\"); &#125; // 通过invoke(实例对象, 参数....) method.invoke(person, 3);&#125;3.4获得该类的所有接口Class[] getInterfaces()：确定此字节码对象所表示的类或接口实现的接口返回值：接口的字节码文件对象的数组3.5获取指定资源的输入流InputStream getResourceAsStream(String name)return：一个 InputStream 对象；如果找不到带有该名称的资源，则返回 null参数：所需资源的名称，如果以”/“开始，则绝对资源名为”/“后面的一部分。四、一个整体的实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package me.zhangsanfeng;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Reflection &#123; public Object copy(Object object) throws Exception&#123; //通过传入的Object得到该实例对应的类的Class对象 Class&lt;?&gt; classType = object.getClass(); //通过Class得到该类的Constructor对象 Constructor&lt;?&gt; cons = classType.getConstructor(new Class[]&#123;&#125;); //通过反射机制使用构造方法得到一个对象，用来接受复制的内容 Object retObject = cons.newInstance(new Object[]&#123;&#125;); //取到实例对应的类的所有成员变量 Field[] fields = classType.getDeclaredFields(); for(Field field:fields)&#123; String nameOfField = field.getName(); /*组装成员变量的get、set方法*/ String fristWord = nameOfField.substring(0, 1).toUpperCase(); String getMethodName = \"get\"+fristWord+nameOfField.substring(1); String setMethodName = \"set\"+fristWord+nameOfField.substring(1); //通过反射创建类中方法的对象 Method getMethod = classType.getMethod(getMethodName, new Class[]&#123;&#125;); Method setMethod = classType.getMethod(setMethodName, new Class[]&#123;field.getType()&#125;); /*使用get方法从传入对象取值，使用set方法将取出的值赋给等待复制的retObject*/ Object value = getMethod.invoke(object, new Object[]&#123;&#125;); setMethod.invoke(retObject, new Object[]&#123;value&#125;); &#125; return retObject; &#125; public static void main(String[] args) throws Exception &#123; //使用反射创建一个person实例 Class&lt;?&gt; classType = Person.class; Constructor cons = classType.getConstructor(new Class[]&#123;String.class,int.class,double.class&#125;); //使用带参数的构造方法创建对象 Object perOfLee = cons.newInstance(new Object[]&#123;\"Lee\",25,8000&#125;); //使用反射调用copy方法 Class &lt;?&gt; classOfReflect = Class.forName(\"me.zhangsanfeng.Reflection\"); Object reflect = classOfReflect.newInstance(); Method methodOfCopy = classOfReflect.getMethod(\"copy\", new Class[]&#123;Object.class&#125;); Object finalObject = methodOfCopy.invoke(reflect, perOfLee); Person copyPerson = (Person)finalObject; //print System.out.println(copyPerson.getName()+\", \"+copyPerson.getAge()+\", \"+copyPerson.getSalary()); &#125;&#125;//定义一个“人”类class Person&#123; private String name; private int age; private double salary; public Person() &#123; &#125; public Person(String name, int age, double salary)&#123; this.name = name; this.age = age; this.salary = salary; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125;","categories":[{"name":"Java底层","slug":"Java底层","permalink":"https://letcoder.cn/categories/Java底层/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"关于同步异步与阻塞非阻塞的理解","slug":"关于同步异步与阻塞非阻塞的理解","date":"2019-09-29T10:20:21.000Z","updated":"2019-09-29T11:10:26.129Z","comments":true,"path":"2019/09/29/关于同步异步与阻塞非阻塞的理解/","link":"","permalink":"https://letcoder.cn/2019/09/29/关于同步异步与阻塞非阻塞的理解/","excerpt":"阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。","text":"阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。1.同步与异步同步和异步 关注的是消息通信机制(synchronous communication/ asynchronous communication)所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用持续等待就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，但是没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。1.1.举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书。如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。2.阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态. (状态划重点)阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程。2.1.还是上面的例子你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。3.再举个详细的例子老张爱喝茶，废话不说，煮开水。出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。12345678910111 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻.2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。3 老张把响水壶放到火上，立等响水壶鸣笛。（异步阻塞）老张觉得这样傻等意义不大4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。所谓同步异步，只是对于水壶而言。普通水壶，同步； 响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张看电视效率的低下。所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然情况3中响水壶是异步的，可对于阻塞立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。——例子来源网络，作者不明。","categories":[{"name":"Java底层","slug":"Java底层","permalink":"https://letcoder.cn/categories/Java底层/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"什么是IOC和AOP","slug":"什么是IOC和AOP","date":"2019-09-26T02:33:06.000Z","updated":"2019-09-26T02:35:43.173Z","comments":true,"path":"2019/09/26/什么是IOC和AOP/","link":"","permalink":"https://letcoder.cn/2019/09/26/什么是IOC和AOP/","excerpt":"","text":"IOCIOC（Inversion Of Controll，控制反转）是一种设计思想，将原本在程序中手动创建对象的控制权，交由给Spring框架来管理。IOC容器是Spring用来实现IOC的载体，IOC容器实际上就是一个Map(key, value)，Map中存放的是各种对象。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。IOC容器就像是一个工厂，当需要创建一个对象，只需要配置好配置文件/注解即可，不用考虑对象是如何被创建出来的，大大增加了项目的可维护性且降低了开发难度。AOPAOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量，提高了系统的扩展性。Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。Spring AOP / AspectJ AOP 的区别？Spring AOP属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。","categories":[{"name":"Java后端","slug":"Java后端","permalink":"https://letcoder.cn/categories/Java后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"Servlet生命周期","slug":"Servlet生命周期","date":"2019-09-19T14:08:42.000Z","updated":"2019-09-19T14:19:17.839Z","comments":true,"path":"2019/09/19/Servlet生命周期/","link":"","permalink":"https://letcoder.cn/2019/09/19/Servlet生命周期/","excerpt":"","text":"生命周期： Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。综上：Servlet生命周期分为三个阶段：初始化阶段 调用init()方法, 只执行一次12345--默认情况下，第一次被访问时，Servlet被创建，然后执行init方法；--可以配置执行Servlet的创建时机；--可以配置执行Servlet的创建时机；响应客户请求阶段 调用service()方法 处理doGet和doPost方法，执行多次终止阶段 当Servlet服务器正常关闭时，执行destroy方法，只执行一次代码：12345678910111213141516171819202122//servlet生命周期，的三个方法，//1.被创建，执行且只执行一次init方法，//2.提供服务，执行service方法，执行多次 //3.被销毁，当Servlet服务器正常关闭时，执行destroy方法，只执行一次。@Overridepublic void init() throws ServletException &#123; // TODO Auto-generated method stub super.init();&#125;@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub super.service(req, resp);&#125;@Overridepublic void destroy() &#123; // TODO Auto-generated method stub super.destroy();&#125;","categories":[{"name":"Java后端","slug":"Java后端","permalink":"https://letcoder.cn/categories/Java后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"Java泛型学习","slug":"Java泛型学习","date":"2019-09-17T11:28:14.000Z","updated":"2019-10-07T13:30:43.172Z","comments":true,"path":"2019/09/17/Java泛型学习/","link":"","permalink":"https://letcoder.cn/2019/09/17/Java泛型学习/","excerpt":"我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。","text":"我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。定义和使用含有泛型的类定义格式：1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125;例如，API中的ArrayList集合：123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125;使用泛型： 即什么时候确定泛型。在创建对象的时候确定泛型例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();此时，变量E的值就是String类型了, 那么我们的类型就可以理解为：123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125;再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125;2.举例自定义泛型类123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125;使用:123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(\"大胡子登登\"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125;含有泛型的方法定义格式：1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123; &#125;例如，123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125;使用格式：调用方法时，确定泛型的类型12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(\"aaa\"); mm.show(123); mm.show(12.45); &#125;&#125;含有泛型的接口定义格式：1修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125;例如，12345public interface MyGenericInterface&lt;E&gt;&#123; public void add(E e); public E getE(); &#125;使用格式：1、定义类时确定泛型的类型例如:1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125;此时，泛型E的值就是String类型。2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型例如1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125;确定泛型：123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(\"aa\"); &#125;&#125;泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。此时只能接受数据,不能往该集合中存储数据。举个例子大家理解使用即可：12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型tips:泛型不存在继承关系 Collectionlist = new ArrayList();这种是错误的。通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。泛型的上限：格式： 类型名称 &lt;? extends 类 &gt; 对象名称意义： 只能接收该类型及其子类泛型的下限：格式： 类型名称 &lt;? super 类 &gt; 对象名称意义： 只能接收该类型及其父类型比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;#","categories":[{"name":"Java底层","slug":"Java底层","permalink":"https://letcoder.cn/categories/Java底层/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"Java中的堆区、栈区、方法区","slug":"Java堆栈","date":"2019-09-15T12:33:09.000Z","updated":"2019-09-26T02:35:21.108Z","comments":true,"path":"2019/09/15/Java堆栈/","link":"","permalink":"https://letcoder.cn/2019/09/15/Java堆栈/","excerpt":"","text":"JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)栈区:每个线程包含一个栈区，栈中只保存方法中（不包括对象的成员变量）的基础数据类型和自定义对象的引用(不是对象)，对象都存放在堆区中每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)堆区:存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的对象实例和数组都在堆中分配。方法区:又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。","categories":[{"name":"Java底层","slug":"Java底层","permalink":"https://letcoder.cn/categories/Java底层/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"centos修改mysql root账户密码","slug":"centos修改mysql-root账户密码","date":"2019-09-05T12:04:29.000Z","updated":"2019-09-05T12:18:20.325Z","comments":true,"path":"2019/09/05/centos修改mysql-root账户密码/","link":"","permalink":"https://letcoder.cn/2019/09/05/centos修改mysql-root账户密码/","excerpt":"","text":"第一步修改my.cnf文件vim /etc/my.cnf在[mysqld]中添加 skip-grant-tables例如：12345[mysqld]skip-grant-tables # 添加这行# skip-grant-tables=1datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock重启mysql1service mysql restart第二步用户无密码登录1mysql -uroot -p (直接点击回车，密码为空)第三步选择数据库修改root密码12use mysql;update mysql.user set authentication_string=password(&apos;新密码&apos;) where User=&apos;用户&apos;;第四步刷新并退出12flush privileges;quit;第五步编辑my.cnf并重启mysql123vim /etc/my.cnf# 删除 skip-grant-tables 保存退出service mysql restart # 重启mysql参考文章文章1文章2","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://letcoder.cn/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://letcoder.cn/tags/Mysql/"}]},{"title":"Mysql忘记密码解决方案","slug":"Mysql忘记密码解决方案","date":"2019-09-04T13:02:38.000Z","updated":"2019-09-04T13:05:02.021Z","comments":true,"path":"2019/09/04/Mysql忘记密码解决方案/","link":"","permalink":"https://letcoder.cn/2019/09/04/Mysql忘记密码解决方案/","excerpt":"","text":"Mysql 忘记了密码 解决方案：Cmd – &gt; 停止mysql服务 （以管理员的身份） net stop mysql;使用无验证方式启动mysql mysqld –skip-grant-tables打开新的cmd窗口，直接输入mysql 回车 登录成功依次执行 use mysql; set password for “root”@”localhost” = password(“新密码”);手动执行mysqld的进程启动mysql服务 net start mysql;使用新密码登录","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://letcoder.cn/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://letcoder.cn/tags/Mysql/"}]},{"title":"springMVC配置定时任务","slug":"springMVC配置定时任务","date":"2019-08-24T13:31:22.000Z","updated":"2019-08-24T13:32:05.974Z","comments":true,"path":"2019/08/24/springMVC配置定时任务/","link":"","permalink":"https://letcoder.cn/2019/08/24/springMVC配置定时任务/","excerpt":"","text":"springMVC配置定时执行任务配置xml在SpringMVC配置文件中添加1234xmlns:task=\"http://www.springframework.org/schema/task\" http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.3.xsd配置任务扫描1&lt;task:annotation-driven /&gt;配置扫描任务位置12&lt;!-- 扫描任务 --&gt;&lt;context:component-scan base-package=\"com.xxx.task\" /&gt;如下图：Demo：12345678910111213package com.kaoqin.task;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class demo &#123; @Scheduled(cron = \"0/5 * * * * ? \") // 间隔5秒执行 public void taskCycle() &#123; System.out.println(\"使用SpringMVC框架配置定时任务\"); &#125;&#125;注意事项：1、spring的 @Scheduled 注解 需要写在实现方法上2、 定时器的任务方法不能有返回值（如果有返回值，spring初始化的时候会告诉你有个错误、需要设定一个proxytargetclass的某个值为true）3、实现类上要有组件的注解@Component扩展：定时时间的设置如：“0/5 ?”CronTrigger配置完整格式为： [秒] [分] [小时] [日] [月] [周] [年]序号说明是否必填允许填写的值允许的通配符1秒是0-59, - * /2分是0-59, - * /3小时是0-23, - * /4日是1-31, - * ? / L W5月是1-12或JAN-DEC, - * /6周是1-7或SUN-SAT, - * ? / L W7年否empty 或1970-2099, - * /通配符说明:* 表示所有值. 例如:在分的字段上设置 “*”,表示每一分钟都会触发。? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?- 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。, 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发/ 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“).# 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：‘L’和 ‘W’可以组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON 与mon相同；参考：https://wuzhuti.cn/850.html/comment-page-1/https://wuzhuti.cn/447.html","categories":[{"name":"Java后端","slug":"Java后端","permalink":"https://letcoder.cn/categories/Java后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"表单onsubmit事件无效&表单onsubmit后使用ajax无效解决","slug":"表单onsubmit事件无效-表单onsubmit后使用ajax无效解决","date":"2019-08-17T12:02:47.000Z","updated":"2019-08-17T12:30:10.598Z","comments":true,"path":"2019/08/17/表单onsubmit事件无效-表单onsubmit后使用ajax无效解决/","link":"","permalink":"https://letcoder.cn/2019/08/17/表单onsubmit事件无效-表单onsubmit后使用ajax无效解决/","excerpt":"","text":"这段时间在写一个h5+app，用于一个组队比赛项目的app。由于自身也没有多少前端开发的经验，也就是闷着头一直乱写，在开发中也遇到了各种难题。今天又解决一发问题，(此处需要掌声)， 成就感！关于登录表单submit的问题这个过程需要用到的技术主要就是ajax技术和js的onsubmit技术。过程如下：1.用户输入 用户名和密码2.当用户点击提交按钮时，利用ajax请求后端接口 进行用户名密码验证。但是这时候出现一个问题，就是当 用户点击输入法的 发送 提交 按钮的时候，我们怎么验证这时候就需要原生js的 onsubmit 方法了3.1 验证不通过，onsubmit返回false，表单无法提交，页面提示用户密码有错。3.2 验证通过，onsubmit返回true，表单提交，服务器返回用户内部视图，登陆成功。废话不说上代码123456789101112131415161718192021222324252627282930313233343536373839// 点击手机键盘 提交按钮document.getElementById(\"login\").onsubmit = function() &#123; subData();&#125;;// 点击登录按钮document.getElementById(\"login-btn\").addEventListener('tap', function() &#123; subData();&#125;)function subData() &#123; // 获取表单数据 var data = getFormData(\"login\"); mui.ajax('http://192.168.1.142:8080/user/login.do', &#123; data: JSON.stringify(&#123; 'username': data.username, 'password': data.password &#125;), dataType: 'json', //服务器返回json格式数据 type: 'post', //HTTP请求类型 timeout: 10000, //超时时间设置为10秒； // async: false, // 同步方式是为了解决 手机键盘提交按钮 提交表单验证bug的 contentType: 'application/json;charset=utf-8', // 少了会报错 success: function(data) &#123; console.log(JSON.stringify(data)); if (data.status == 200) &#123; mui.toast(\"登录成功\") &#125; else if (data.status == -200) &#123; mui.toast(\"登录失败，请重新登录\") &#125; &#125;, error: function(xhr, type, errorThrown) &#123; console.log(\"error\"); &#125; &#125;);&#125;;如果用上面的代码，点击手机键盘 提交按钮 是无法完成验证操作的、原因上面代码用的是 异步的方式123456789&lt;script type=\"text/javascript\"&gt; function checkpwd()&#123; //1............ $.ajax(&#123; //2........ &#125;); //3......... &#125;&lt;/script&gt;如果是同步方式：当1执行完毕后，接着执行ajax，线程会处于等待状态，等2执行完毕之后，接着执行3.如果是异步方式：当1执行完毕之后，接着执行ajax，但是ajax不会阻塞主线程，ajax执行的同时会执行3.下面展示错误的ajax验证方式：1234567891011121314151617181920212223// 点击手机键盘 提交按钮document.getElementById(\"login\").onsubmit = function() &#123; // 1........ mui.ajax('http://192.168.1.142:8080/user/login.do', &#123; // 2....... data: JSON.stringify(&#123; 'username': data.username, 'password': data.password &#125;), dataType: 'json', //服务器返回json格式数据 type: 'post', //HTTP请求类型 contentType: 'application/json;charset=utf-8', // 少了会报错 success: function(data) &#123; console.log(\"success\"); &#125;, error: function(xhr, type, errorThrown) &#123; console.log(\"error\"); &#125; &#125;); // 3........&#125;;上面的代码， 先执行 1 后 执行 2 。但是2 (ajax) 不会阻塞主线程，2 (ajax) 执行的同时会执行3. 这时候3 没等验证成功，立马返回false因此，当使用异步方式进行验证的时候，会出现无论如何，onsubmit（onclick）都不会起作用，这会让程序员感觉自己的代码有问题，其实代码没问题，是逻辑的问题。要解决这个问题，我们就必须用ajax的同步方式。解决方案改为同步方式 ajax 中添加1async : false,参考文章文章1","categories":[{"name":"HTML5+APP","slug":"HTML5-APP","permalink":"https://letcoder.cn/categories/HTML5-APP/"}],"tags":[{"name":"Web移动端","slug":"Web移动端","permalink":"https://letcoder.cn/tags/Web移动端/"}]},{"title":"Mybatis查询parameterType多参数问题","slug":"Mybatis查询parameterType多参数问题","date":"2019-08-15T13:32:45.000Z","updated":"2019-08-15T13:48:07.978Z","comments":true,"path":"2019/08/15/Mybatis查询parameterType多参数问题/","link":"","permalink":"https://letcoder.cn/2019/08/15/Mybatis查询parameterType多参数问题/","excerpt":"","text":"Mybatis查询parameterType多参数问题一、单个参数：123456List&lt;EntInfo&gt; findByUsername(String username);&lt;select id=\"findByUsername\" resultMap=\"EntInfoResultMap\" parameterType=\"java.lang.String\" &gt;.......&lt;/select&gt;其中方法名和ID一致，#{} 中的参数名与方法中的参数名一致， 这里采用的是@Param这个参数，实际上@Param这个最后会被Mabatis封装为map类型的。select 后的字段列表要和bean中的属性名一致， 如果不一致的可以用 as 来补充。二、多参数：方案1123456789public List&lt;XXX&gt; getXXX(String xxId, String xxCode); &lt;select id=\"getXXX\" resultType=\"XXX\"&gt; // 不需要写parameterType参数 select t.* from tableName where id = #&#123;0&#125; and name = #&#123;1&#125; &lt;/select&gt; // 由于是多参数那么就不能使用parameterType， 改用#｛index｝是第几个就用第几个的索引，索引从0开始方案2（推荐）基于注解1234567public List&lt;XXXBean&gt; getXXXBeanList(@Param(\"id\")String id, @Param(\"code\")String code); &lt;select id=\"getXXXBeanList\" resultType=\"XXBean\"&gt; select t.* from tableName where id = #&#123;id&#125; and name = #&#123;code&#125; &lt;/select&gt;由于是多参数那么就不能使用parameterType， 这里用@Param来指定哪一个。三、map封装多参数：通过传入map对象查询 并返回user对象的list集合直接通过map里面的key直接访问 #{key}123456public List&lt;User&gt; findUsersByMap(Map&lt;String, Object&gt; map);&lt;!-- 3. 通过传入map对象查询 并返回user对象的list集合 map里面的属性直接访问 --&gt;&lt;select id=\"findUsersByMap\" parameterType=\"hashmap\" resultType=\"user\"&gt; select * from users where sex=#&#123;sex&#125; and username =#&#123;name&#125;&lt;/select&gt;四、List封装多个参数：12345678910public List&lt;XXX&gt; getXXX(List&lt;String&gt; list); &lt;select id=\"getXXXBeanList\" resultType=\"XXBean\"&gt; select 字段... from XXX where id in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt; // foreach 最后的效果是select 字段... from XXX where id in ('1','2','3','4')","categories":[{"name":"Java后端","slug":"Java后端","permalink":"https://letcoder.cn/categories/Java后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"HTML5+app实现文件上传(java后端)","slug":"HTML5-app实现文件上传-java后端","date":"2019-08-13T12:18:59.000Z","updated":"2019-08-15T13:34:33.681Z","comments":true,"path":"2019/08/13/HTML5-app实现文件上传-java后端/","link":"","permalink":"https://letcoder.cn/2019/08/13/HTML5-app实现文件上传-java后端/","excerpt":"","text":"以拍照上传，相册选择图片上传为例HTML5 Plus 拍照或者相册选择图片上传到服务器起因：正在写一个人脸识别打卡签到的webApp，其中需要一个拍摄照片并上传服务器的功能通过阅读h5+官方文档 了解到有相册 、相机、 文件上传等接口下面学习这几个api：1、从图库选择图片1234567891011121314151617181920212223242526272829303132plus.gallery.pick( function(path) &#123; // path为选择图片的路径 // 下面将图片显示在界面 hui('#img3 div').hide(); hui('#img3 img').attr('src', path); hui('#img3 img').show(); // 上传文件 imgUpload(path); &#125;, function(e) &#123; hui.toast(\"上传失败\"); &#125;, &#123; filter: 'image', system: false &#125;)// 选择多张图片plus.gallery.pick( function(paths)&#123; for(i in paths.files)&#123; hui.toast(paths.files[i]); //imgUpload(path); &#125; &#125;, function(e)&#123; hui.toast('取消了选择'); &#125;,&#123; filter: 'image', multiple: true, maximum: 5 &#125;);2、相机获取图片123456789101112131415plus.camera.getCamera().captureImage( function(path) &#123; // 这个path 不能直接使用 是相对的 需要进行路径转换 var url = \"file://\" + plus.io.convertLocalFileSystemURL(path); // 路径转换 hui('#img2 div').hide(); hui('#img2 img').attr('src', path); hui('#img2 img').show(); imgUpload(path); &#125;, function(e) &#123; hui.toast(\"上传失败\"); &#125;, &#123; index: 2 // 拍照时默认的摄像头 1后置 2 前置 &#125;)3、uploader文件上传原理应该就是通过http 的post请求上传文件12345678910111213141516171819202122232425/** * 图片上传（java后端测试成功） * @param &#123;Object&#125; path */function imgUpload(path) &#123; plus.nativeUI.showWaiting(); var task = plus.uploader.createUpload( 'http://192.168.1.142:8080/img/upload.do', &#123; method: \"POST\" &#125;, function(resp, status) &#123; if (status == 200) &#123; plus.nativeUI.closeWaiting(); console.log(resp.responseText); mui.toast('上传成功'); &#125; else &#123; mui.toast('上传失败'); plus.nativeUI.closeWaiting(); &#125; &#125; ); task.addFile(path, &#123;key: 'file'&#125;); // 这里必须和 java后端的 @RequestParam(value = \"file\") 对应 task.addData(\"name\", \"test\"); task.start();&#125;代码就是上述所写，server为上传的服务端接口地址，如果上传成功，则回调的status会返回200，不成功或者接口参数有问题会返回400或者500。resp.responseText 服务端返回的结果，一般服务端会返回json，解析一下json就可以使用了。传输其他文件时如果还想添加其他参数，用.addData(key,value),添加图片用.addFile(图片路径，{key:后端接收文件的名字})， 这个key必须和后端接收名字对应配合后端代码看会好理解，后端我用java接收的：4、Java后端接收并保存用标准的MultipartFile接收即可。注意xml限制的大小设定springMVC.xml123456&lt;!--配置文件上传--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\" /&gt; &lt;!--单位字节--&gt; &lt;property name=\"maxUploadSize\" value=\"20480000\"/&gt;&lt;/bean&gt;1234567891011121314151617181920212223242526272829303132333435@RequestMapping(value = \"/upload\", produces = \"text/html;charset=utf-8\")@ResponseBodypublic String uploadImg(@RequestParam(value = \"file\") MultipartFile file, HttpServletRequest request) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); try &#123; String oriFilename = file.getOriginalFilename(); // 获取文件后缀 String fileType = oriFilename.substring(oriFilename.lastIndexOf(\".\") + 1, oriFilename.length()).toLowerCase(); // 存储路径 String basePath = \"/Users/qxqzx/Desktop/img/\"; // 保存的文件名字 String saveName = String.valueOf(new Date().getTime()) + \".\" + fileType; File dst = new File(basePath, saveName); if (!dst.getParentFile().exists()) &#123; dst.mkdirs(); &#125; file.transferTo(dst); // 写入本地 map.put(\"success\", true); map.put(\"code\", \"200\"); map.put(\"msg\", \"图片上传成功！\"); &#125; catch (IOException e) &#123; e.printStackTrace(); map.put(\"success\", false); map.put(\"code\", \"-200\"); map.put(\"msg\", \"图片上传失败！\"); &#125; return JSON.toJSONString(map);&#125;暂时总结到这, 等后续补充","categories":[{"name":"HTML5+APP","slug":"HTML5-APP","permalink":"https://letcoder.cn/categories/HTML5-APP/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://letcoder.cn/tags/Web前端/"},{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"hexo 报错 Cannot read property 'replace' of null","slug":"hexo-报错-Cannot-read-property-replace-of-null","date":"2019-08-12T11:41:24.000Z","updated":"2019-08-12T11:45:05.625Z","comments":true,"path":"2019/08/12/hexo-报错-Cannot-read-property-replace-of-null/","link":"","permalink":"https://letcoder.cn/2019/08/12/hexo-报错-Cannot-read-property-replace-of-null/","excerpt":"","text":"hexo配置文件进行相应的修改1234deploy: type: git repo: https://github.com/qxqzx/qxqzx.github.io.git branch: master执行命令1hexo g -d就报错了：1FATAL Cannot read property &apos;replace&apos; of null解决：看帖子都是说 _config.yml 配置文件中的url 设置错误我的设置：12345# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; url: root: /permalink: :year/:month/:day/:title/permalink_defaults:看了下url果然有错，加上url后好了执行 hexo g -d 成功。参考链接hexo issues #2006hexo issues #2141cd2want","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://letcoder.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://letcoder.cn/tags/Hexo/"}]},{"title":"新启程，一个新的开始","slug":"新启程，一个新的开始","date":"2019-08-12T11:36:24.000Z","updated":"2019-08-12T11:40:46.281Z","comments":true,"path":"2019/08/12/新启程，一个新的开始/","link":"","permalink":"https://letcoder.cn/2019/08/12/新启程，一个新的开始/","excerpt":"","text":"这是一个全新开始建立这个新的站点，来记录一些东西。以前的站点 用的是typecho已经鸽了一个月，没更新内容。不在打算更新。今天开始 转为 Hexo站点，原因是 这个主题太好看了","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://letcoder.cn/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://letcoder.cn/tags/杂谈/"}]},{"title":"Hexo新开始","slug":"Hexo新开始","date":"2019-08-12T10:50:11.503Z","updated":"2019-08-12T11:37:27.680Z","comments":true,"path":"2019/08/12/Hexo新开始/","link":"","permalink":"https://letcoder.cn/2019/08/12/Hexo新开始/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://letcoder.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://letcoder.cn/tags/Hexo/"}]}]}