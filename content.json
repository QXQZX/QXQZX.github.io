{"meta":{"title":"QXQZX's blog","subtitle":null,"description":"爱生活, 爱代码, 记录生活, 记录代码","author":"QXQZX","url":"https://letcoder.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-09-15T14:04:36.739Z","updated":"2019-09-15T13:05:57.957Z","comments":true,"path":"404.html","permalink":"https://letcoder.cn/404.html","excerpt":"","text":"404 Not Found很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"2019-09-16T11:25:09.271Z","updated":"2019-09-16T11:25:09.271Z","comments":true,"path":"friends/index.html","permalink":"https://letcoder.cn/friends/index.html","excerpt":"","text":"这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～名称： QXQZX’s Blog头像： https://blog.zxnest.club/logo.png网址： https://blog.zxnest.club/标签： Java"},{"title":"所有分类","date":"2019-09-15T13:38:44.767Z","updated":"2019-09-15T13:38:44.767Z","comments":true,"path":"categories/index.html","permalink":"https://letcoder.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-09-15T13:06:29.340Z","updated":"2019-09-15T12:58:08.162Z","comments":true,"path":"about/index.html","permalink":"https://letcoder.cn/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425262728&#123; name: 'QXQZX' age: 19, gender: '男', profession: 'Student &amp; Coder', experience: '0年', address: '山东省淄博市', education: '本科在校', github: 'https://github.com/QXQZX', blog: 'https://letcoder.cn', email: '501966782@qq.com', description: '一杯水，一包烟，一个bug玩一天', skills: [ ['Html', 'JavaScript', 'jQuery', 'CSS', 'ES6', 'Node', 'Bootstrap'], ['Git', 'Linux'], ['Java', 'Spring', 'SpringMVC', 'Mybatis'], ['Mysql'], ['数据结构'] ], devTools: [ ['Sublime Text', 'Visual Studio Code', 'Hbuilder'], ['Chrome DevTools', 'Fiddler'], ['Idea', 'Eclipse'], ['Navicat', 'Terminal'], ] &#125;"},{"title":"所有标签","date":"2019-09-15T13:36:23.167Z","updated":"2019-09-15T13:36:23.167Z","comments":true,"path":"tags/index.html","permalink":"https://letcoder.cn/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-09-15T13:40:07.491Z","updated":"2019-09-15T13:40:07.491Z","comments":true,"path":"projects/index.html","permalink":"https://letcoder.cn/projects/index.html","excerpt":"","text":""}],"posts":[{"title":"Servlet生命周期","slug":"Servlet生命周期","date":"2019-09-19T14:08:42.000Z","updated":"2019-09-19T14:14:55.759Z","comments":true,"path":"2019/09/19/Servlet生命周期/","link":"","permalink":"https://letcoder.cn/2019/09/19/Servlet生命周期/","excerpt":"","text":"Servlet生命周期分为三个阶段：初始化阶段 调用init()方法, 只执行一次12345--默认情况下，第一次被访问时，Servlet被创建，然后执行init方法；--可以配置执行Servlet的创建时机；--可以配置执行Servlet的创建时机；响应客户请求阶段 调用service()方法 处理doGet和doPost方法，执行多次终止阶段 当Servlet服务器正常关闭时，执行destroy方法，只执行一次12345678910111213141516171819202122//servlet生命周期，的三个方法，//1.被创建，执行且只执行一次init方法，//2.提供服务，执行service方法，执行多次 //3.被销毁，当Servlet服务器正常关闭时，执行destroy方法，只执行一次。@Overridepublic void init() throws ServletException &#123; // TODO Auto-generated method stub super.init();&#125;@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub super.service(req, resp);&#125;@Overridepublic void destroy() &#123; // TODO Auto-generated method stub super.destroy();&#125;","categories":[{"name":"Java后端","slug":"Java后端","permalink":"https://letcoder.cn/categories/Java后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"Java泛型学习","slug":"Java泛型学习","date":"2019-09-17T11:28:14.000Z","updated":"2019-09-17T11:57:22.547Z","comments":true,"path":"2019/09/17/Java泛型学习/","link":"","permalink":"https://letcoder.cn/2019/09/17/Java泛型学习/","excerpt":"我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。","text":"我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。定义和使用含有泛型的类定义格式：1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125;例如，API中的ArrayList集合：123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125;使用泛型： 即什么时候确定泛型。在创建对象的时候确定泛型例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();此时，变量E的值就是String类型了, 那么我们的类型就可以理解为：123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125;再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125;2.举例自定义泛型类123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125;使用:123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(\"大胡子登登\"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125;含有泛型的方法定义格式：1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123; &#125;例如，123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125;使用格式：调用方法时，确定泛型的类型12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(\"aaa\"); mm.show(123); mm.show(12.45); &#125;&#125;含有泛型的接口定义格式：1修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125;例如，12345public interface MyGenericInterface&lt;E&gt;&#123; public void add(E e); public E getE(); &#125;使用格式：1、定义类时确定泛型的类型例如:1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125;此时，泛型E的值就是String类型。2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型例如1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125;确定泛型：123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(\"aa\"); &#125;&#125;泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。此时只能接受数据,不能往该集合中存储数据。举个例子大家理解使用即可：12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型tips:泛型不存在继承关系 Collectionlist = new ArrayList();这种是错误的。通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。泛型的上限：格式： 类型名称 &lt;? extends 类 &gt; 对象名称意义： 只能接收该类型及其子类泛型的下限：格式： 类型名称 &lt;? super 类 &gt; 对象名称意义： 只能接收该类型及其父类型比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;#","categories":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"Java中的堆区、栈区、方法区","slug":"Java堆栈","date":"2019-09-15T12:33:09.000Z","updated":"2019-09-17T11:57:27.015Z","comments":true,"path":"2019/09/15/Java堆栈/","link":"","permalink":"https://letcoder.cn/2019/09/15/Java堆栈/","excerpt":"","text":"JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)栈区:每个线程包含一个栈区，栈中只保存方法中（不包括对象的成员变量）的基础数据类型和自定义对象的引用(不是对象)，对象都存放在堆区中每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)堆区:存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的对象实例和数组都在堆中分配。方法区:又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。","categories":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"centos修改mysql root账户密码","slug":"centos修改mysql-root账户密码","date":"2019-09-05T12:04:29.000Z","updated":"2019-09-05T12:18:20.325Z","comments":true,"path":"2019/09/05/centos修改mysql-root账户密码/","link":"","permalink":"https://letcoder.cn/2019/09/05/centos修改mysql-root账户密码/","excerpt":"","text":"第一步修改my.cnf文件vim /etc/my.cnf在[mysqld]中添加 skip-grant-tables例如：12345[mysqld]skip-grant-tables # 添加这行# skip-grant-tables=1datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock重启mysql1service mysql restart第二步用户无密码登录1mysql -uroot -p (直接点击回车，密码为空)第三步选择数据库修改root密码12use mysql;update mysql.user set authentication_string=password(&apos;新密码&apos;) where User=&apos;用户&apos;;第四步刷新并退出12flush privileges;quit;第五步编辑my.cnf并重启mysql123vim /etc/my.cnf# 删除 skip-grant-tables 保存退出service mysql restart # 重启mysql参考文章文章1文章2","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://letcoder.cn/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://letcoder.cn/tags/Mysql/"}]},{"title":"Mysql忘记密码解决方案","slug":"Mysql忘记密码解决方案","date":"2019-09-04T13:02:38.000Z","updated":"2019-09-04T13:05:02.021Z","comments":true,"path":"2019/09/04/Mysql忘记密码解决方案/","link":"","permalink":"https://letcoder.cn/2019/09/04/Mysql忘记密码解决方案/","excerpt":"","text":"Mysql 忘记了密码 解决方案：Cmd – &gt; 停止mysql服务 （以管理员的身份） net stop mysql;使用无验证方式启动mysql mysqld –skip-grant-tables打开新的cmd窗口，直接输入mysql 回车 登录成功依次执行 use mysql; set password for “root”@”localhost” = password(“新密码”);手动执行mysqld的进程启动mysql服务 net start mysql;使用新密码登录","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://letcoder.cn/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://letcoder.cn/tags/Mysql/"}]},{"title":"springMVC配置定时任务","slug":"springMVC配置定时任务","date":"2019-08-24T13:31:22.000Z","updated":"2019-08-24T13:32:05.974Z","comments":true,"path":"2019/08/24/springMVC配置定时任务/","link":"","permalink":"https://letcoder.cn/2019/08/24/springMVC配置定时任务/","excerpt":"","text":"springMVC配置定时执行任务配置xml在SpringMVC配置文件中添加1234xmlns:task=\"http://www.springframework.org/schema/task\" http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.3.xsd配置任务扫描1&lt;task:annotation-driven /&gt;配置扫描任务位置12&lt;!-- 扫描任务 --&gt;&lt;context:component-scan base-package=\"com.xxx.task\" /&gt;如下图：Demo：12345678910111213package com.kaoqin.task;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class demo &#123; @Scheduled(cron = \"0/5 * * * * ? \") // 间隔5秒执行 public void taskCycle() &#123; System.out.println(\"使用SpringMVC框架配置定时任务\"); &#125;&#125;注意事项：1、spring的 @Scheduled 注解 需要写在实现方法上2、 定时器的任务方法不能有返回值（如果有返回值，spring初始化的时候会告诉你有个错误、需要设定一个proxytargetclass的某个值为true）3、实现类上要有组件的注解@Component扩展：定时时间的设置如：“0/5 ?”CronTrigger配置完整格式为： [秒] [分] [小时] [日] [月] [周] [年]序号说明是否必填允许填写的值允许的通配符1秒是0-59, - * /2分是0-59, - * /3小时是0-23, - * /4日是1-31, - * ? / L W5月是1-12或JAN-DEC, - * /6周是1-7或SUN-SAT, - * ? / L W7年否empty 或1970-2099, - * /通配符说明:* 表示所有值. 例如:在分的字段上设置 “*”,表示每一分钟都会触发。? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?- 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。, 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发/ 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“).# 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：‘L’和 ‘W’可以组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON 与mon相同；参考：https://wuzhuti.cn/850.html/comment-page-1/https://wuzhuti.cn/447.html","categories":[{"name":"Java后端","slug":"Java后端","permalink":"https://letcoder.cn/categories/Java后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"表单onsubmit事件无效&表单onsubmit后使用ajax无效解决","slug":"表单onsubmit事件无效-表单onsubmit后使用ajax无效解决","date":"2019-08-17T12:02:47.000Z","updated":"2019-08-17T12:30:10.598Z","comments":true,"path":"2019/08/17/表单onsubmit事件无效-表单onsubmit后使用ajax无效解决/","link":"","permalink":"https://letcoder.cn/2019/08/17/表单onsubmit事件无效-表单onsubmit后使用ajax无效解决/","excerpt":"","text":"这段时间在写一个h5+app，用于一个组队比赛项目的app。由于自身也没有多少前端开发的经验，也就是闷着头一直乱写，在开发中也遇到了各种难题。今天又解决一发问题，(此处需要掌声)， 成就感！关于登录表单submit的问题这个过程需要用到的技术主要就是ajax技术和js的onsubmit技术。过程如下：1.用户输入 用户名和密码2.当用户点击提交按钮时，利用ajax请求后端接口 进行用户名密码验证。但是这时候出现一个问题，就是当 用户点击输入法的 发送 提交 按钮的时候，我们怎么验证这时候就需要原生js的 onsubmit 方法了3.1 验证不通过，onsubmit返回false，表单无法提交，页面提示用户密码有错。3.2 验证通过，onsubmit返回true，表单提交，服务器返回用户内部视图，登陆成功。废话不说上代码123456789101112131415161718192021222324252627282930313233343536373839// 点击手机键盘 提交按钮document.getElementById(\"login\").onsubmit = function() &#123; subData();&#125;;// 点击登录按钮document.getElementById(\"login-btn\").addEventListener('tap', function() &#123; subData();&#125;)function subData() &#123; // 获取表单数据 var data = getFormData(\"login\"); mui.ajax('http://192.168.1.142:8080/user/login.do', &#123; data: JSON.stringify(&#123; 'username': data.username, 'password': data.password &#125;), dataType: 'json', //服务器返回json格式数据 type: 'post', //HTTP请求类型 timeout: 10000, //超时时间设置为10秒； // async: false, // 同步方式是为了解决 手机键盘提交按钮 提交表单验证bug的 contentType: 'application/json;charset=utf-8', // 少了会报错 success: function(data) &#123; console.log(JSON.stringify(data)); if (data.status == 200) &#123; mui.toast(\"登录成功\") &#125; else if (data.status == -200) &#123; mui.toast(\"登录失败，请重新登录\") &#125; &#125;, error: function(xhr, type, errorThrown) &#123; console.log(\"error\"); &#125; &#125;);&#125;;如果用上面的代码，点击手机键盘 提交按钮 是无法完成验证操作的、原因上面代码用的是 异步的方式123456789&lt;script type=\"text/javascript\"&gt; function checkpwd()&#123; //1............ $.ajax(&#123; //2........ &#125;); //3......... &#125;&lt;/script&gt;如果是同步方式：当1执行完毕后，接着执行ajax，线程会处于等待状态，等2执行完毕之后，接着执行3.如果是异步方式：当1执行完毕之后，接着执行ajax，但是ajax不会阻塞主线程，ajax执行的同时会执行3.下面展示错误的ajax验证方式：1234567891011121314151617181920212223// 点击手机键盘 提交按钮document.getElementById(\"login\").onsubmit = function() &#123; // 1........ mui.ajax('http://192.168.1.142:8080/user/login.do', &#123; // 2....... data: JSON.stringify(&#123; 'username': data.username, 'password': data.password &#125;), dataType: 'json', //服务器返回json格式数据 type: 'post', //HTTP请求类型 contentType: 'application/json;charset=utf-8', // 少了会报错 success: function(data) &#123; console.log(\"success\"); &#125;, error: function(xhr, type, errorThrown) &#123; console.log(\"error\"); &#125; &#125;); // 3........&#125;;上面的代码， 先执行 1 后 执行 2 。但是2 (ajax) 不会阻塞主线程，2 (ajax) 执行的同时会执行3. 这时候3 没等验证成功，立马返回false因此，当使用异步方式进行验证的时候，会出现无论如何，onsubmit（onclick）都不会起作用，这会让程序员感觉自己的代码有问题，其实代码没问题，是逻辑的问题。要解决这个问题，我们就必须用ajax的同步方式。解决方案改为同步方式 ajax 中添加1async : false,参考文章文章1","categories":[{"name":"HTML5+APP","slug":"HTML5-APP","permalink":"https://letcoder.cn/categories/HTML5-APP/"}],"tags":[{"name":"Web移动端","slug":"Web移动端","permalink":"https://letcoder.cn/tags/Web移动端/"}]},{"title":"Mybatis查询parameterType多参数问题","slug":"Mybatis查询parameterType多参数问题","date":"2019-08-15T13:32:45.000Z","updated":"2019-08-15T13:48:07.978Z","comments":true,"path":"2019/08/15/Mybatis查询parameterType多参数问题/","link":"","permalink":"https://letcoder.cn/2019/08/15/Mybatis查询parameterType多参数问题/","excerpt":"","text":"Mybatis查询parameterType多参数问题一、单个参数：123456List&lt;EntInfo&gt; findByUsername(String username);&lt;select id=\"findByUsername\" resultMap=\"EntInfoResultMap\" parameterType=\"java.lang.String\" &gt;.......&lt;/select&gt;其中方法名和ID一致，#{} 中的参数名与方法中的参数名一致， 这里采用的是@Param这个参数，实际上@Param这个最后会被Mabatis封装为map类型的。select 后的字段列表要和bean中的属性名一致， 如果不一致的可以用 as 来补充。二、多参数：方案1123456789public List&lt;XXX&gt; getXXX(String xxId, String xxCode); &lt;select id=\"getXXX\" resultType=\"XXX\"&gt; // 不需要写parameterType参数 select t.* from tableName where id = #&#123;0&#125; and name = #&#123;1&#125; &lt;/select&gt; // 由于是多参数那么就不能使用parameterType， 改用#｛index｝是第几个就用第几个的索引，索引从0开始方案2（推荐）基于注解1234567public List&lt;XXXBean&gt; getXXXBeanList(@Param(\"id\")String id, @Param(\"code\")String code); &lt;select id=\"getXXXBeanList\" resultType=\"XXBean\"&gt; select t.* from tableName where id = #&#123;id&#125; and name = #&#123;code&#125; &lt;/select&gt;由于是多参数那么就不能使用parameterType， 这里用@Param来指定哪一个。三、map封装多参数：通过传入map对象查询 并返回user对象的list集合直接通过map里面的key直接访问 #{key}123456public List&lt;User&gt; findUsersByMap(Map&lt;String, Object&gt; map);&lt;!-- 3. 通过传入map对象查询 并返回user对象的list集合 map里面的属性直接访问 --&gt;&lt;select id=\"findUsersByMap\" parameterType=\"hashmap\" resultType=\"user\"&gt; select * from users where sex=#&#123;sex&#125; and username =#&#123;name&#125;&lt;/select&gt;四、List封装多个参数：12345678910public List&lt;XXX&gt; getXXX(List&lt;String&gt; list); &lt;select id=\"getXXXBeanList\" resultType=\"XXBean\"&gt; select 字段... from XXX where id in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt; // foreach 最后的效果是select 字段... from XXX where id in ('1','2','3','4')","categories":[{"name":"Java后端","slug":"Java后端","permalink":"https://letcoder.cn/categories/Java后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"HTML5+app实现文件上传(java后端)","slug":"HTML5-app实现文件上传-java后端","date":"2019-08-13T12:18:59.000Z","updated":"2019-08-15T13:34:33.681Z","comments":true,"path":"2019/08/13/HTML5-app实现文件上传-java后端/","link":"","permalink":"https://letcoder.cn/2019/08/13/HTML5-app实现文件上传-java后端/","excerpt":"","text":"以拍照上传，相册选择图片上传为例HTML5 Plus 拍照或者相册选择图片上传到服务器起因：正在写一个人脸识别打卡签到的webApp，其中需要一个拍摄照片并上传服务器的功能通过阅读h5+官方文档 了解到有相册 、相机、 文件上传等接口下面学习这几个api：1、从图库选择图片1234567891011121314151617181920212223242526272829303132plus.gallery.pick( function(path) &#123; // path为选择图片的路径 // 下面将图片显示在界面 hui('#img3 div').hide(); hui('#img3 img').attr('src', path); hui('#img3 img').show(); // 上传文件 imgUpload(path); &#125;, function(e) &#123; hui.toast(\"上传失败\"); &#125;, &#123; filter: 'image', system: false &#125;)// 选择多张图片plus.gallery.pick( function(paths)&#123; for(i in paths.files)&#123; hui.toast(paths.files[i]); //imgUpload(path); &#125; &#125;, function(e)&#123; hui.toast('取消了选择'); &#125;,&#123; filter: 'image', multiple: true, maximum: 5 &#125;);2、相机获取图片123456789101112131415plus.camera.getCamera().captureImage( function(path) &#123; // 这个path 不能直接使用 是相对的 需要进行路径转换 var url = \"file://\" + plus.io.convertLocalFileSystemURL(path); // 路径转换 hui('#img2 div').hide(); hui('#img2 img').attr('src', path); hui('#img2 img').show(); imgUpload(path); &#125;, function(e) &#123; hui.toast(\"上传失败\"); &#125;, &#123; index: 2 // 拍照时默认的摄像头 1后置 2 前置 &#125;)3、uploader文件上传原理应该就是通过http 的post请求上传文件12345678910111213141516171819202122232425/** * 图片上传（java后端测试成功） * @param &#123;Object&#125; path */function imgUpload(path) &#123; plus.nativeUI.showWaiting(); var task = plus.uploader.createUpload( 'http://192.168.1.142:8080/img/upload.do', &#123; method: \"POST\" &#125;, function(resp, status) &#123; if (status == 200) &#123; plus.nativeUI.closeWaiting(); console.log(resp.responseText); mui.toast('上传成功'); &#125; else &#123; mui.toast('上传失败'); plus.nativeUI.closeWaiting(); &#125; &#125; ); task.addFile(path, &#123;key: 'file'&#125;); // 这里必须和 java后端的 @RequestParam(value = \"file\") 对应 task.addData(\"name\", \"test\"); task.start();&#125;代码就是上述所写，server为上传的服务端接口地址，如果上传成功，则回调的status会返回200，不成功或者接口参数有问题会返回400或者500。resp.responseText 服务端返回的结果，一般服务端会返回json，解析一下json就可以使用了。传输其他文件时如果还想添加其他参数，用.addData(key,value),添加图片用.addFile(图片路径，{key:后端接收文件的名字})， 这个key必须和后端接收名字对应配合后端代码看会好理解，后端我用java接收的：4、Java后端接收并保存用标准的MultipartFile接收即可。注意xml限制的大小设定springMVC.xml123456&lt;!--配置文件上传--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\" /&gt; &lt;!--单位字节--&gt; &lt;property name=\"maxUploadSize\" value=\"20480000\"/&gt;&lt;/bean&gt;1234567891011121314151617181920212223242526272829303132333435@RequestMapping(value = \"/upload\", produces = \"text/html;charset=utf-8\")@ResponseBodypublic String uploadImg(@RequestParam(value = \"file\") MultipartFile file, HttpServletRequest request) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); try &#123; String oriFilename = file.getOriginalFilename(); // 获取文件后缀 String fileType = oriFilename.substring(oriFilename.lastIndexOf(\".\") + 1, oriFilename.length()).toLowerCase(); // 存储路径 String basePath = \"/Users/qxqzx/Desktop/img/\"; // 保存的文件名字 String saveName = String.valueOf(new Date().getTime()) + \".\" + fileType; File dst = new File(basePath, saveName); if (!dst.getParentFile().exists()) &#123; dst.mkdirs(); &#125; file.transferTo(dst); // 写入本地 map.put(\"success\", true); map.put(\"code\", \"200\"); map.put(\"msg\", \"图片上传成功！\"); &#125; catch (IOException e) &#123; e.printStackTrace(); map.put(\"success\", false); map.put(\"code\", \"-200\"); map.put(\"msg\", \"图片上传失败！\"); &#125; return JSON.toJSONString(map);&#125;暂时总结到这, 等后续补充","categories":[{"name":"HTML5+APP","slug":"HTML5-APP","permalink":"https://letcoder.cn/categories/HTML5-APP/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://letcoder.cn/tags/Web前端/"},{"name":"Java","slug":"Java","permalink":"https://letcoder.cn/tags/Java/"}]},{"title":"hexo 报错 Cannot read property 'replace' of null","slug":"hexo-报错-Cannot-read-property-replace-of-null","date":"2019-08-12T11:41:24.000Z","updated":"2019-08-12T11:45:05.625Z","comments":true,"path":"2019/08/12/hexo-报错-Cannot-read-property-replace-of-null/","link":"","permalink":"https://letcoder.cn/2019/08/12/hexo-报错-Cannot-read-property-replace-of-null/","excerpt":"","text":"hexo配置文件进行相应的修改1234deploy: type: git repo: https://github.com/qxqzx/qxqzx.github.io.git branch: master执行命令1hexo g -d就报错了：1FATAL Cannot read property &apos;replace&apos; of null解决：看帖子都是说 _config.yml 配置文件中的url 设置错误我的设置：12345# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; url: root: /permalink: :year/:month/:day/:title/permalink_defaults:看了下url果然有错，加上url后好了执行 hexo g -d 成功。参考链接hexo issues #2006hexo issues #2141cd2want","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://letcoder.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://letcoder.cn/tags/Hexo/"}]},{"title":"新启程，一个新的开始","slug":"新启程，一个新的开始","date":"2019-08-12T11:36:24.000Z","updated":"2019-08-12T11:40:46.281Z","comments":true,"path":"2019/08/12/新启程，一个新的开始/","link":"","permalink":"https://letcoder.cn/2019/08/12/新启程，一个新的开始/","excerpt":"","text":"这是一个全新开始建立这个新的站点，来记录一些东西。以前的站点 用的是typecho已经鸽了一个月，没更新内容。不在打算更新。今天开始 转为 Hexo站点，原因是 这个主题太好看了","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://letcoder.cn/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://letcoder.cn/tags/杂谈/"}]},{"title":"Hexo新开始","slug":"Hexo新开始","date":"2019-08-12T10:50:11.503Z","updated":"2019-08-12T11:37:27.680Z","comments":true,"path":"2019/08/12/Hexo新开始/","link":"","permalink":"https://letcoder.cn/2019/08/12/Hexo新开始/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://letcoder.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://letcoder.cn/tags/Hexo/"}]}]}