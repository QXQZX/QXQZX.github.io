<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>aassssssss</title>
      <link href="/2019/12/15/aassssssss/"/>
      <url>/2019/12/15/aassssssss/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AVL平衡二叉树学习</title>
      <link href="/2019/12/14/AVL-tree/"/>
      <url>/2019/12/14/AVL-tree/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p><strong>平衡二叉树(AVL)，</strong>是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。高度平衡？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</p><a id="more"></a><h3 id="平衡二叉树特点"><a href="#平衡二叉树特点" class="headerlink" title="平衡二叉树特点"></a>平衡二叉树特点</h3><p><strong>平衡因子BF：</strong><br>指的是二叉树左子树深度减去右子树深度。<br>平衡因子只能是-1,0,1。只要二叉树有一个节点的平衡因子绝对值大于1，则该树就不平衡了。</p><p>一棵AVL树有如下必要条件：</p><ol><li>条件一：它必须是二叉排序树。</li><li>条件二：每个节点的左子树和右子树的高度差至多为1。也就是说平衡因子绝对值不超过1</li></ol><h3 id="实用性分析"><a href="#实用性分析" class="headerlink" title="实用性分析"></a>实用性分析</h3><p>AVL平衡二叉树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），这得益于它时刻维护着二叉树的平衡。如果我们需要查找的集合本身没有顺序，在频繁查找的同时也经常的插入和删除，AVL树是不错的选择。不平衡的二叉查找树在查找时的效率是很低的，因此，AVL如何维护二叉树的平衡是我们的学习重点。</p><hr><h3 id="四种旋转方式"><a href="#四种旋转方式" class="headerlink" title="四种旋转方式"></a>四种旋转方式</h3><p><img src="https://tvax3.sinaimg.cn/large/006nIlf0ly1g9wkw68fdvj319s0oegph.jpg" alt="旋转方式"></p><h4 id="LL型旋转"><a href="#LL型旋转" class="headerlink" title="LL型旋转"></a>LL型旋转</h4><p>由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B顺时针旋转一样。</p><p>LL型调整的一般形式如下图所示，表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。</p><p><img src="https://tva2.sinaimg.cn/large/006nIlf0ly1g9wl6dpfngj30ms0a3mxe.jpg" alt></p><h4 id="RR型旋转"><a href="#RR型旋转" class="headerlink" title="RR型旋转"></a>RR型旋转</h4><p>和LL型旋转类似</p><p>表示在A的右孩子B的右子树BR(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将A的右孩子B提升为新的根结点；②将原来的根结点A降为B的左孩子；③各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。</p><p><img src="https://tva1.sinaimg.cn/large/006nIlf0ly1g9wl6izdyqj30mi0agq36.jpg" alt></p><h4 id="LR型旋转"><a href="#LR型旋转" class="headerlink" title="LR型旋转"></a>LR型旋转</h4><p>表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的右孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子，B变为C的左孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。</p><p><img src="https://tva1.sinaimg.cn/large/006nIlf0ly1g9wlbzq4lhj30nv0ant94.jpg" alt></p><p><strong>等价于 先一次RR旋转再一次LL旋转。先对B右孩子C及C的右孩子进行RR旋转，再对A,B,C进行LL旋转。</strong></p><p><img src="https://tva1.sinaimg.cn/large/006nIlf0ly1g9wlpkpjw3j30m906njs4.jpg" alt></p><h4 id="RL型旋转"><a href="#RL型旋转" class="headerlink" title="RL型旋转"></a>RL型旋转</h4><p>表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子，B变为C的右孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。</p><p><img src="https://tva4.sinaimg.cn/large/006nIlf0ly1g9wlc3skaej30nc0a23yy.jpg" alt></p><p><strong>等价于 先一次LL旋转再一次RR旋转。先对B左孩子C及C的左孩子进行LL旋转，再对A,B,C进行RR旋转。</strong></p><p><img src="https://tvax2.sinaimg.cn/large/006nIlf0ly1g9wlpmyadhj30m706nmxx.jpg" alt></p><hr><h3 id="C-C-代码实现"><a href="#C-C-代码实现" class="headerlink" title="C/C++代码实现"></a>C/C++代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E [3374] - 数据结构实验之查找二：平衡二叉树</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">//记录关键字数值</span></span><br><span class="line">    node *l, *r;</span><br><span class="line">    <span class="keyword">int</span> height;  <span class="comment">//当前节点的高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(node *p)</span>  <span class="comment">//求树的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">LL</span><span class="params">(node *p)</span>  <span class="comment">//对LL型直接在不平衡结点进行左旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *q = p-&gt;l;  <span class="comment">// q是p的左子树</span></span><br><span class="line">    p-&gt;l = q-&gt;r;  <span class="comment">// q的右子树值一定小于p-&gt;data  所以p-&gt;l连上q-&gt;r</span></span><br><span class="line">    q-&gt;r = p;     <span class="comment">// q-&gt;r连上p 画图理解</span></span><br><span class="line">    p-&gt;height = max(height(p-&gt;l), height(p-&gt;r)) + <span class="number">1</span>;  <span class="comment">// 要更新结点的高度值</span></span><br><span class="line">    q-&gt;height = max(height(q-&gt;l), p-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">RR</span><span class="params">(node *p)</span>  <span class="comment">//对RR型直接在不平衡结点进行右旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *q = p-&gt;r;  <span class="comment">// 连接原理与LL相同</span></span><br><span class="line">    p-&gt;r = q-&gt;l;</span><br><span class="line">    q-&gt;l = p;</span><br><span class="line">    p-&gt;height = max(height(p-&gt;l), height(p-&gt;r)) + <span class="number">1</span>;</span><br><span class="line">    q-&gt;height = max(height(q-&gt;r), p-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">LR</span><span class="params">(node *p)</span> </span>&#123;</span><br><span class="line">    p-&gt;l = RR(p-&gt;l);  <span class="comment">//在不平衡结点p的左孩子以及左孩子的孩子进行RR旋转</span></span><br><span class="line">    <span class="keyword">return</span> LL(p);  <span class="comment">//在不平衡结点p处进行LL并返回新的根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">RL</span><span class="params">(node *p)</span> </span>&#123;</span><br><span class="line">    p-&gt;r = LL(p-&gt;r);  <span class="comment">//在不平衡结点p的右孩子以及右孩子的孩子进行LL旋转</span></span><br><span class="line">    <span class="keyword">return</span> RR(p);  <span class="comment">//在不平衡结点p处进行RR并返回新的根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//待插入的值赋给新开辟的结点</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> node;</span><br><span class="line">        p-&gt;data = k;</span><br><span class="line">        p-&gt;height = <span class="number">0</span>;</span><br><span class="line">        p-&gt;l = p-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;data) &#123;</span><br><span class="line">        <span class="comment">// 若待插入的值小于p的关键字数值，则插入到左子树中</span></span><br><span class="line">        insert(p-&gt;l, k);</span><br><span class="line">        <span class="comment">// 若该树出现不平衡 旋转</span></span><br><span class="line">        <span class="keyword">if</span> (height(p-&gt;l) - height(p-&gt;r) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; p-&gt;l-&gt;data)  <span class="comment">// 若待插入的值插到了左子树的左子树上则单旋转</span></span><br><span class="line">                p = LL(p);</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//若待插入的值插到了左子树的右子树上则单旋转</span></span><br><span class="line">                p = LR(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; p-&gt;data) &#123;</span><br><span class="line">        <span class="comment">// 若待插入的值小于p的关键字数值，则插入到右子树中</span></span><br><span class="line">        insert(p-&gt;r, k);</span><br><span class="line">        <span class="keyword">if</span> (height(p-&gt;r) - height(p-&gt;l) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 若待插入的值插到了右子树的右子树上则单旋转</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; p-&gt;r-&gt;data)</span><br><span class="line">                p = RR(p);</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 若待插入的值插到了右子树的左子树上则单旋转</span></span><br><span class="line">                p = RL(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;height = max(height(p-&gt;l), height(p-&gt;r)) + <span class="number">1</span>;  <span class="comment">// 修改高度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        node *head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            insert(head, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推荐学习资料"><a href="#推荐学习资料" class="headerlink" title="推荐学习资料"></a>推荐学习资料</h3><p>b站视频连接：<br><a href="https://www.bilibili.com/video/av37955102?from=search&amp;seid=14638889623357631324" target="_blank" rel="noopener">https://www.bilibili.com/video/av37955102?from=search&amp;seid=14638889623357631324</a></p><p><a href="https://www.bilibili.com/video/av37955178?from=search&amp;seid=14638889623357631324" target="_blank" rel="noopener">https://www.bilibili.com/video/av37955178?from=search&amp;seid=14638889623357631324</a></p><p><a href="https://www.bilibili.com/video/av37955231?from=search&amp;seid=14638889623357631324" target="_blank" rel="noopener">https://www.bilibili.com/video/av37955231?from=search&amp;seid=14638889623357631324</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/isunbin/article/details/81707606" target="_blank" rel="noopener">平衡二叉树</a></li><li><a href></a></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>equals与==的区别</title>
      <link href="/2019/11/26/equals%E4%B8%8E%E7%AD%89%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/26/equals%E4%B8%8E%E7%AD%89%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><h3 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h3><p>一、基本数据类型 用(==) 进行比较的时候，比较的实际值</p><p>二、包装数据类型 用(==)进行比较的时候，比较的是在内存中存放的地址</p><p>三、包装类型中的equals方法，（String，Integer，Date）等重写了equals方法，比较的是地址和内容，地址相同返回true，地址不同但值相同返回true，其他返回false。没有重写equals方法的，比较的还是内存地址。</p><p>四、StringBuffer 和 StringBuilder 比较特殊， == 和 equals都是比较的地址。</p><hr><p>推荐文章</p><p><a href="https://blog.csdn.net/qq_36522306/article/details/80550210" target="_blank" rel="noopener">https://blog.csdn.net/qq_36522306/article/details/80550210</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态工厂和实例工厂区别</title>
      <link href="/2019/10/19/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/10/19/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>在学习Spring bean的实例化方式的时候遇到的一个问题，Spring bean实例化有3种方法</p><ul><li>通过类的构造器生成</li><li>通过静态工厂方法创建</li><li>通过实例工厂方法创建</li></ul><p>那么问题来了，什么是静态工厂方法，什么是实例工厂方法？两者有什么区别呢？</p><h2 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h2><blockquote><p>就是直接可以通过静态方法来实例化一个对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloWorld <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建的时候</span></span><br><span class="line">HelloWorldFactory.getInstance();</span><br></pre></td></tr></table></figure><blockquote><p>创建 HelloWorld 对象直接可以调用getInstance方法来进行实现</p></blockquote><h2 id="实例工厂方法"><a href="#实例工厂方法" class="headerlink" title="实例工厂方法"></a>实例工厂方法</h2><blockquote><p>就是先创建类对象，如何通过对象来调用创建实例对象的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">createHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建的时候</span></span><br><span class="line">HelloWorldFactory helloFactory = <span class="keyword">new</span> HelloWorldFactory();</span><br><span class="line">helloFactory.createHelloWorld();</span><br></pre></td></tr></table></figure><h1 id="关于applicationContext-xml"><a href="#关于applicationContext-xml" class="headerlink" title="关于applicationContext.xml"></a>关于applicationContext.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        创建对象的第二种方式：利用静态工厂方法</span></span><br><span class="line"><span class="comment">        factory-method：静态工厂类的获取对象的静态方法</span></span><br><span class="line"><span class="comment">        class:静态工厂类的全类名</span></span><br><span class="line"><span class="comment">静态工厂方法 工厂不需要实例化</span></span><br><span class="line"><span class="comment"> --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"HelloStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstances"</span> <span class="attr">class</span>=<span class="string">"com.coder.ioc.HelloStaticFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        创建对象的第三种方式：利用实例工厂方法</span></span><br><span class="line"><span class="comment">        factory-bean:指定当前Spring中包含工厂方法的beanID</span></span><br><span class="line"><span class="comment">        factory-method:工厂方法名称</span></span><br><span class="line"><span class="comment">实例工厂方法是先将工厂实例化</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"HelloInstanceFactory"</span> <span class="attr">class</span>=<span class="string">"com.coder.ioc.HelloInstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instance"</span> <span class="attr">factory-bean</span>=<span class="string">"HelloInstanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解学习</title>
      <link href="/2019/10/07/Java-annotation/"/>
      <url>/2019/10/07/Java-annotation/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>注释：用文字描述程序，给程序员看的</p><p>注解：给机器看的</p><a id="more"></a><h2 id="1-注解基础知识点"><a href="#1-注解基础知识点" class="headerlink" title="1.注解基础知识点"></a>1.注解基础知识点</h2><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p><h3 id="1-1作用分类："><a href="#1-1作用分类：" class="headerlink" title="1.1作用分类："></a>1.1作用分类：</h3><p>①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</p><p>②代码分析：通过代码里标识的元数据对代码进行分析【使用反射】</p><p>③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查，编译检查是否是复写父类的方法【Override】</p><p>给某个类、方法..添加了一个注解，这个环节仅仅是做了一个标记，对代码本身并不会造成任何影响，需要后续环节的配合，需要其他方法对该注解赋予业务逻辑处理。就如同我们在微信上发了一个共享定位，此时并没有什么用，只有当后面其他人都进入了这个共享定位，大家之间的距离才能明确，才知道该怎么聚在一起。</p><h3 id="1-2注解分为三类："><a href="#1-2注解分为三类：" class="headerlink" title="1.2注解分为三类："></a>1.2注解分为三类：</h3><h4 id="1-2-1编译器使用到的注解"><a href="#1-2-1编译器使用到的注解" class="headerlink" title="1.2.1编译器使用到的注解"></a>1.2.1编译器使用到的注解</h4><p>如@Override，@SuppressWarnings都是编译器使用到的注解，作用是告诉编译器一些事情，而不会进入编译后的.class文件。</p><p>@Override：告诉编译器检查一下是否重写了父类的方法；</p><p>@SuppressWarnings：告诉编译器忽略该段代码产生的警告；</p><p>对于开发人员来说，都是直接使用，无需进行其他操作</p><h4 id="1-2-2-class文件使用到注解"><a href="#1-2-2-class文件使用到注解" class="headerlink" title="1.2.2.class文件使用到注解"></a>1.2.2.class文件使用到注解</h4><p>需要通过工具对.class字节码文件进行修改的一些注解，某些工具会在类加载的时候，动态修改用某注解标注的.class文件，从而实现一些特殊的功能，一次性处理完成后，并不会存在于内存中，都是非常底层的工具库、框架会使用，对于开发人员来说，一般不会涉及到。</p><h4 id="1-2-3运行期读取的注解"><a href="#1-2-3运行期读取的注解" class="headerlink" title="1.2.3运行期读取的注解"></a>1.2.3运行期读取的注解</h4><p>一直存在于JVM中，在运行期间可以读取的注解，也是最常用的注解，如Spring的@Controller，@Service，@Repository，@AutoWired，Mybatis的@Mapper，Junit的@Test等，这类注解很多都是工具框架自定义在运行期间发挥特殊作用的注解，一般开发人员也可以自定义这类注解。</p><h2 id="2-自定义注解："><a href="#2-自定义注解：" class="headerlink" title="2.自定义注解："></a>2.自定义注解：</h2><h3 id="2-1格式："><a href="#2-1格式：" class="headerlink" title="2.1格式："></a>2.1格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123;</span><br><span class="line">  <span class="comment">//属性列表：</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2本质："><a href="#2-2本质：" class="headerlink" title="2.2本质："></a>2.2本质：</h3><p>注解的本质就是一个接口，该接口默认继承java.lang.annotation.Annotation</p><p>public interface myAnnotation extends java.lang.annotation.Annotation {<br>}</p><h3 id="2-3属性"><a href="#2-3属性" class="headerlink" title="2.3属性"></a>2.3属性</h3><p>接口中可以自定的成员方法 === 抽象方法</p><p>返回类型要求： 不能是包装类型</p><ol><li>8种基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ol><p>要求：</p><ol><li><p>定义了属性，在使用时需要给属性赋值 （可以设置默认值） String name() default “”;</p></li><li><p>特殊的属性 只有一个属性需要赋值，且属性的名字的是value 书写注解的时候可以省略vlaue=</p><blockquote><p>@myAnnotation(name = “辉”) ==&gt; @myAnnotation(“辉”)</p></blockquote></li><li><p>数组赋值的时候，使用{}包裹。如果数组中只有一个值，则{}省略</p></li></ol><p>注解样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> myAnnotation &#123;</span><br><span class="line">    <span class="comment">// 下面代表一个个的属性  default代表默认</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">myAnno2 <span class="title">ANNO_2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span>[] Arr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@myAnnotation</span>(value = <span class="string">"xx"</span>, age = <span class="number">11</span>, p = Person.p1, ANNO_2 = <span class="meta">@myAnno</span>2, Arr = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">woker</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4元注解"><a href="#2-4元注解" class="headerlink" title="2.4元注解"></a>2.4元注解</h3><p>定义： 用于描述注解的注解 元注解也可以描述元注解</p><p>@Target： 描述注解能够作用的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) <span class="comment">// 只能作用于类</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD) <span class="comment">// 只能作用于方法</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD) <span class="comment">// 只能作用于字段</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;) <span class="comment">// 作用于多个</span></span><br><span class="line"><span class="comment">//.....other</span></span><br></pre></td></tr></table></figure><p>@Retention：描述注解被保留的阶段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【默认策略】，在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 始终不会丢弃，可以使用反射获得该注解的信息。自定义的注解最常用的使用方式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Documented：描述注解是否会被抽取到文档中</p><p>表示是否将此注解的相关信息添加到javadoc文档中</p><p>@Inherited：描述注解是否被子类继承</p><p>定义该注解和子类的关系，使用此注解声明出来的自定义注解，在使用在类上面时，子类会自动继承此注解，否则，子类不会继承此注解。注意，使用@Inherited声明出来的注解，只有在类上使用时才会有效，对方法，属性等其他无效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "man"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Person</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类也拥有@Person注解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5定义注解小结"><a href="#2-5定义注解小结" class="headerlink" title="2.5定义注解小结"></a>2.5定义注解小结</h3><p>用@interface定义注解</p><p>可以添加多个参数，核心参数按约定用value，为每个参数可以设置默认值，参数类型包括基本类型、String和枚举</p><p>可以使用元注解来修饰注解，元注解包括多个，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>。</p><h2 id="3-Annotation解析处理"><a href="#3-Annotation解析处理" class="headerlink" title="3.Annotation解析处理"></a>3.Annotation解析处理</h2><h3 id="3-1解析处理"><a href="#3-1解析处理" class="headerlink" title="3.1解析处理"></a>3.1解析处理</h3><p>含注解的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Colum</span>(<span class="string">"辉"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Colum</span>(<span class="string">"18"</span>)</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">  List&lt;String&gt; colums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 获取目标类的字节码</span></span><br><span class="line">  Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.demo.Annotation.User"</span>);</span><br><span class="line">  <span class="comment">// 获取该类中所有字段</span></span><br><span class="line">  Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="comment">// 获取类中每一个字段的Colum注解</span></span><br><span class="line">    Colum col = field.getAnnotation(Colum.class);</span><br><span class="line">    <span class="comment">// 或者可以先判断有无该注解</span></span><br><span class="line">    field.isAnnotationPresent(Colum.class);</span><br><span class="line">    <span class="comment">// 添加进集合</span></span><br><span class="line">    colums.add(col.value());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印集合</span></span><br><span class="line">  colums.forEach((name) -&gt; System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们有一些常见的应用场景，需要把网站上的列表导出成excel表格，我们通过注解的方式把列名配置好，再通过反射读取实体需要导出（是否需要导出，也可通过注解配置）的每个字段的值，从而实现 excel导出的组件。</p><h3 id="3-2注解底层原理"><a href="#3-2注解底层原理" class="headerlink" title="3.2注解底层原理"></a>3.2注解底层原理</h3><p>注解定义后也是一种class，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Colum &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其实只要在类上、方法上、字段上声明注解后</strong></p><p><strong>就会根据注解上写的相关的value值生成一个.class</strong></p><p>上面注解生成一个 注解接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColumImpl</span> <span class="keyword">implements</span> <span class="title">Colum</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"声明注解时填写的内容"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"声明注解时填写的内容"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后 获取注解接口实现类实例对象 col</span></span><br><span class="line">Colum col = field.getAnnotation(Colum.class);</span><br><span class="line"><span class="comment">// 然后就可以通过对象储存的值 和 强大的反射 进行一系列操作了</span></span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本文只是抛砖引玉地讲解了注解的基本概念，注解的作用，几种元注解的功用以及使用方法，并通过一个简单的例子讲解了一下注解的处理，并不全面，文中通过Field讲解了注解的基本Api，但注解还可以修饰类、构造器、方法等，也有相对应的注解处理方法，大家可自行查一下API手册相关内容，大同小异，有不对之处，请批评指正，望共同进步，谢谢！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制深入学习</title>
      <link href="/2019/09/30/Java-reflex/"/>
      <url>/2019/09/30/Java-reflex/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p><strong>反射是框架设计的灵魂（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）</strong></p><a id="more"></a><h3 id="一、反射的概述"><a href="#一、反射的概述" class="headerlink" title="一、反射的概述"></a>一、反射的概述</h3><p>Java反射机制是在运行状态中，对于任意一个类(class文件)，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是<strong>Class类</strong>中的方法。所以先要获取到每一个字节码文件对应的Class类型的对象。</p><p>反射就是把java类中的各种成分映射成一个个的Java对象。例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把一个个组成部分映射成一个个对象。</p><p>（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）。</p><p><strong>以上的总结就是什么是反射</strong></p><p><br></p><p>如图是类的正常加载过程：反射的原理在与class对象。</p><p>熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p><h3 id="二、获取字节码对象的三种方式。"><a href="#二、获取字节码对象的三种方式。" class="headerlink" title="二、获取字节码对象的三种方式。"></a>二、获取字节码对象的三种方式。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class class1 = Class.forName(<span class="string">"cn.coder.Person"</span>);　<span class="comment">// 常用的</span></span><br><span class="line"><span class="comment">//通过Class类中的静态方法forName，直接获取到一个类的字节码文件对象，此时该类还是源文件阶段，并没有变为字节码文件。</span></span><br><span class="line"></span><br><span class="line">Class class2 = Person.class;</span><br><span class="line"><span class="comment">//当类被加载成.class文件时，此时Person类变成了.class，在获取该字节码文件对象，也就是获取自己， 该类处于字节码阶段。</span></span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Preson();</span><br><span class="line">Class class3 = person.getClass();　</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类的实例获取该类的字节码文件对象，该类处于创建对象阶段</span></span><br></pre></td></tr></table></figure><p>有了字节码文件对象才能获得类中所有的信息，我们在使用反射获取信息时，也要考虑使用上面哪种方式获取字节码对象合理，视不同情况而定。</p><h3 id="三、优雅的利用字节码对象"><a href="#三、优雅的利用字节码对象" class="headerlink" title="三、优雅的利用字节码对象"></a>三、优雅的利用字节码对象</h3><p>下面通过一个实例介绍Class类的功能</p><h4 id="3-1通过字节码对象获取构造器实例对象"><a href="#3-1通过字节码对象获取构造器实例对象" class="headerlink" title="3.1通过字节码对象获取构造器实例对象"></a>3.1通过字节码对象获取构造器实例对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">Class class1 = Class.forName(<span class="string">"cn.coder.Person"</span>);</span><br><span class="line">Person p1 = (Person)class1.newInstance(); <span class="comment">// 通过无参构造器 创建Person实例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局限：</span></span><br><span class="line"><span class="comment">该类无参的构造方法来是使用该Class类的newInstance()方法来创建对象的, 如果一个类没有无参的构造函数, 就不能这样创建了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">Class class2 = Class.forName(<span class="string">"cn.coder.Person"</span>);</span><br><span class="line">Construnctor con = class2.getConstructor(<span class="keyword">int</span>.class, String.class);</span><br><span class="line">Construnctor con0 = class2.getConstructor(<span class="keyword">new</span> Class[] &#123;<span class="keyword">int</span>.class, String.class&#125;); <span class="comment">//效果同上</span></span><br><span class="line">Person p2 = (Person)con.newInstance(<span class="number">18</span>,<span class="string">"臭弟弟"</span>);</span><br><span class="line">Person p0 = (Person)con0.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">18</span>, <span class="string">"臭弟弟"</span>&#125;); <span class="comment">// 效果同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种   其实还可以  获取所有构造器</span></span><br><span class="line">Constructor[] con = class2.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;con.length; i++)&#123;</span><br><span class="line">  <span class="comment">//获取每个构造函数中的参数类型字节码对象</span></span><br><span class="line">  Class[] parameterTypes = con[i].getParameterTypes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;paraparameterTypes.length; j++)&#123;</span><br><span class="line">    <span class="comment">//获取每个构造函数中的参数类型</span></span><br><span class="line">    System.out.print(paraparameterTypes[j].getName() + <span class="string">","</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2获取成员变量并使用—Filed对象"><a href="#3-2获取成员变量并使用—Filed对象" class="headerlink" title="3.2获取成员变量并使用—Filed对象"></a>3.2获取成员变量并使用—Filed对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类变量</span></span><br><span class="line">Field[] fields = personClass.getFields(); <span class="comment">// 只能获取public修饰的变量</span></span><br><span class="line">Field[] fields1 =personClass.getDeclaredFields(); <span class="comment">// 获取所有变量</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">Field a = personClass.getField(<span class="string">"a"</span>);  <span class="comment">// 获取名为a的变量</span></span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Object value = a.get(p); <span class="comment">// 获取p对象中a的值</span></span><br><span class="line">a.set(p, <span class="string">"111"</span>); <span class="comment">// 设置p对象中a的值</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">Field d = personClass.getDeclaredField(<span class="string">"d"</span>);</span><br><span class="line"><span class="comment">// 假设d是private的  则不能get  set</span></span><br><span class="line"><span class="comment">// 那么要开启set  get权限  如下语句开启</span></span><br><span class="line">d.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-3获得方法并使用-Method"><a href="#3-3获得方法并使用-Method" class="headerlink" title="3.3获得方法并使用 Method"></a>3.3获得方法并使用 Method</h4><p><strong>和上面类似 Fileld相似的</strong></p><p>可以通过Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法可以获取类中的指定方法或者所有方法，获取后可进行遍历。如果为私有方法，则需要打开一个权限。setAccessible(true); 用invoke(Object, Object…)可以调用该方法，跟上面同理，也能一次性获得所有的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class p2 = Class.forName(<span class="string">"com.demo.Reflect.Person"</span>); <span class="comment">// 创建字节码对象</span></span><br><span class="line">Person person = (Person) p2.newInstance(); <span class="comment">// 通过字节码实例一个对象</span></span><br><span class="line"></span><br><span class="line">Method[] method2 = p2.getDeclaredMethods(); <span class="comment">// 获取所有method数组</span></span><br><span class="line"><span class="keyword">for</span> (Method method : method2) &#123;</span><br><span class="line">  method.setAccessible(<span class="keyword">true</span>); <span class="comment">// 开启权限</span></span><br><span class="line">  System.out.println(method.getName());</span><br><span class="line">  <span class="comment">// 获取对象的参数 并遍历打印</span></span><br><span class="line">  Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">    System.out.print(parameterTypes[i].getName() + <span class="string">","</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 通过invoke(实例对象, 参数....)</span></span><br><span class="line">  method.invoke(person, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4获得该类的所有接口"><a href="#3-4获得该类的所有接口" class="headerlink" title="3.4获得该类的所有接口"></a>3.4获得该类的所有接口</h4><p>Class[] getInterfaces()：确定此字节码对象所表示的类或接口实现的接口</p><p>返回值：<strong>接口的字节码文件对象的数组</strong></p><h4 id="3-5获取指定资源的输入流"><a href="#3-5获取指定资源的输入流" class="headerlink" title="3.5获取指定资源的输入流"></a>3.5获取指定资源的输入流</h4><p>InputStream getResourceAsStream(String name)</p><p>return：一个 InputStream 对象；如果找不到带有该名称的资源，则返回 null</p><p>参数：所需资源的名称，如果以”/“开始，则绝对资源名为”/“后面的一部分。</p><h4 id="四、一个整体的实例"><a href="#四、一个整体的实例" class="headerlink" title="四、一个整体的实例"></a>四、一个整体的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.zhangsanfeng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">copy</span><span class="params">(Object object)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//通过传入的Object得到该实例对应的类的Class对象</span></span><br><span class="line">    Class&lt;?&gt; classType = object.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Class得到该类的Constructor对象</span></span><br><span class="line">    Constructor&lt;?&gt; cons = classType.getConstructor(<span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过反射机制使用构造方法得到一个对象，用来接受复制的内容</span></span><br><span class="line">    Object retObject = cons.newInstance(<span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取到实例对应的类的所有成员变量</span></span><br><span class="line">    Field[] fields = classType.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Field field:fields)&#123;</span><br><span class="line">      String nameOfField = field.getName();</span><br><span class="line">      <span class="comment">/*组装成员变量的get、set方法*/</span></span><br><span class="line">      String fristWord = nameOfField.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase();</span><br><span class="line">      String getMethodName = <span class="string">"get"</span>+fristWord+nameOfField.substring(<span class="number">1</span>);</span><br><span class="line">      String setMethodName = <span class="string">"set"</span>+fristWord+nameOfField.substring(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//通过反射创建类中方法的对象</span></span><br><span class="line">      Method getMethod = classType.getMethod(getMethodName, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">      Method setMethod = classType.getMethod(setMethodName, <span class="keyword">new</span> Class[]&#123;field.getType()&#125;);</span><br><span class="line">      <span class="comment">/*使用get方法从传入对象取值，使用set方法将取出的值赋给等待复制的retObject*/</span></span><br><span class="line">      Object value = getMethod.invoke(object, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">      setMethod.invoke(retObject, <span class="keyword">new</span> Object[]&#123;value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用反射创建一个person实例</span></span><br><span class="line">    Class&lt;?&gt; classType = Person.class;</span><br><span class="line">    Constructor cons = classType.getConstructor(<span class="keyword">new</span> Class[]&#123;String.class,<span class="keyword">int</span>.class,<span class="keyword">double</span>.class&#125;);</span><br><span class="line">    <span class="comment">//使用带参数的构造方法创建对象</span></span><br><span class="line">    Object perOfLee = cons.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">"Lee"</span>,<span class="number">25</span>,<span class="number">8000</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用反射调用copy方法</span></span><br><span class="line">    Class &lt;?&gt; classOfReflect = Class.forName(<span class="string">"me.zhangsanfeng.Reflection"</span>);</span><br><span class="line">    Object reflect = classOfReflect.newInstance();</span><br><span class="line">    Method methodOfCopy = classOfReflect.getMethod(<span class="string">"copy"</span>, <span class="keyword">new</span> Class[]&#123;Object.class&#125;);</span><br><span class="line">    Object finalObject = methodOfCopy.invoke(reflect, perOfLee);</span><br><span class="line">    Person copyPerson = (Person)finalObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print</span></span><br><span class="line">    System.out.println(copyPerson.getName()+<span class="string">", "</span>+copyPerson.getAge()+<span class="string">", "</span>+copyPerson.getSalary());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个“人”类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于同步异步与阻塞非阻塞的理解</title>
      <link href="/2019/09/29/%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/09/29/%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。</p><a id="more"></a><h3 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1.同步与异步"></a>1.同步与异步</h3><p><strong>同步和异步</strong> 关注的是<strong>消息通信机制</strong>(synchronous communication/ asynchronous communication)</p><p><strong>所谓同步</strong>，就是在发出一个调用时，在没有得到结果之前，该调用持续等待就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。</p><p><strong>而异步则是相反</strong>，调用在发出之后，这个调用就直接返回了，但是没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><h4 id="1-1-举个通俗的例子："><a href="#1-1-举个通俗的例子：" class="headerlink" title="1.1.举个通俗的例子："></a>1.1.举个通俗的例子：</h4><p>你打电话问书店老板有没有《分布式系统》这本书。</p><p>如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p><p><br></p><h3 id="2-阻塞与非阻塞"><a href="#2-阻塞与非阻塞" class="headerlink" title="2.阻塞与非阻塞"></a>2.阻塞与非阻塞</h3><p><strong>阻塞和非阻塞</strong>关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong> (状态划重点)</p><p><strong>阻塞调用</strong>是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br><strong>非阻塞调用</strong>是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><h4 id="2-1-还是上面的例子"><a href="#2-1-还是上面的例子" class="headerlink" title="2.1.还是上面的例子"></a>2.1.还是上面的例子</h4><p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p><p><br></p><h3 id="3-再举个详细的例子"><a href="#3-再举个详细的例子" class="headerlink" title="3.再举个详细的例子"></a>3.再举个详细的例子</h3><p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span> <span class="string">老张把水壶放到火上，立等水开。（同步阻塞）</span></span><br><span class="line"><span class="attr">老张觉得自己有点傻.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2</span> <span class="string">老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</span></span><br><span class="line"><span class="attr">老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3</span> <span class="string">老张把响水壶放到火上，立等响水壶鸣笛。（异步阻塞）</span></span><br><span class="line"><span class="attr">老张觉得这样傻等意义不大</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4</span> <span class="string">老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</span></span><br><span class="line"><span class="attr">老张觉得自己聪明了。</span></span><br></pre></td></tr></table></figure><p><strong>所谓同步异步，只是对于水壶而言。</strong><br>普通水壶，同步； 响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张看电视效率的低下。</p><p><strong>所谓阻塞非阻塞，仅仅对于老张而言。</strong><br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然情况3中响水壶是异步的，可对于阻塞立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p><blockquote><p>——例子来源网络，作者不明。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是IOC和AOP</title>
      <link href="/2019/09/26/IOC-AOP/"/>
      <url>/2019/09/26/IOC-AOP/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC（Inversion Of Controll，控制反转）是一种设计思想，将原本在程序中手动创建对象的控制权，交由给Spring框架来管理。IOC容器是Spring用来实现IOC的载体，IOC容器实际上就是一个Map(key, value)，Map中存放的是各种对象。</p><p>这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。IOC容器就像是一个工厂，当需要创建一个对象，只需要配置好配置文件/注解即可，不用考虑对象是如何被创建出来的，大大增加了项目的可维护性且降低了开发难度。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量，提高了系统的扩展性。</p><p>Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。</p><h3 id="Spring-AOP-AspectJ-AOP-的区别？"><a href="#Spring-AOP-AspectJ-AOP-的区别？" class="headerlink" title="Spring AOP / AspectJ AOP 的区别？"></a>Spring AOP / AspectJ AOP 的区别？</h3><p>Spring AOP属于运行时增强，而AspectJ是编译时增强。</p><p>Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。</p><p>AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet生命周期</title>
      <link href="/2019/09/19/servlet-declaration/"/>
      <url>/2019/09/19/servlet-declaration/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><p>综上：</p><p>Servlet生命周期分为三个阶段：</p><ol><li>初始化阶段 调用init()方法, 只执行一次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--默认情况下，第一次被访问时，Servlet被创建，然后执行init方法；</span><br><span class="line"></span><br><span class="line">--可以配置执行Servlet的创建时机；</span><br><span class="line"></span><br><span class="line">--可以配置执行Servlet的创建时机；</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><p>响应客户请求阶段 调用service()方法 处理doGet和doPost方法，执行多次</p></li><li><p>终止阶段　当Servlet服务器正常关闭时，执行destroy方法，只执行一次</p></li></ol><p><br></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//servlet生命周期，的三个方法，</span></span><br><span class="line"><span class="comment">//1.被创建，执行且只执行一次init方法，</span></span><br><span class="line"><span class="comment">//2.提供服务，执行service方法，执行多次 </span></span><br><span class="line"><span class="comment">//3.被销毁，当Servlet服务器正常关闭时，执行destroy方法，只执行一次。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">super</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">super</span>.service(req, resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">super</span>.destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型学习</title>
      <link href="/2019/09/17/Java%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/17/Java%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><a id="more"></a><h2 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h2><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用泛型： 即什么时候确定泛型。<strong>在创建对象的时候确定泛型</strong></p><p>例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p></li></ol><p>此时，变量E的值就是String类型了, 那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>2.举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line"><span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    </span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">"大胡子登登"</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);     </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">"aaa"</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p><strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection<object>list = new ArrayList<string>();这种是错误的。</string></object></p></blockquote><p><br></p><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>#</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的堆区、栈区、方法区</title>
      <link href="/2019/09/15/java-memory-model/"/>
      <url>/2019/09/15/java-memory-model/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</p><p><br></p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区:"></a>栈区:</h3><ol><li><strong>每个线程包含一个栈区</strong>，栈中只保存方法中（不包括对象的成员变量）的<strong>基础数据类型和自定义对象的引用(不是对象)</strong>，对象都存放在堆区中</li><li>每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。</li><li>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)</li></ol><p><br><br></p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区:"></a>堆区:</h3><ol><li>存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。</li><li><strong>jvm只有一个堆区(heap)被所有线程共享</strong>，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的<strong>对象实例和数组</strong>都在堆中分配。</li></ol><p><br><br></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区:"></a>方法区:</h3><ol><li>又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos修改mysql root账户密码</title>
      <link href="/2019/09/05/centos%E4%BF%AE%E6%94%B9mysql-root%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81/"/>
      <url>/2019/09/05/centos%E4%BF%AE%E6%94%B9mysql-root%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><h3 id="第一步修改my-cnf文件"><a href="#第一步修改my-cnf文件" class="headerlink" title="第一步修改my.cnf文件"></a>第一步修改my.cnf文件</h3><ol><li><p>vim /etc/my.cnf</p></li><li><p>在[mysqld]中添加 skip-grant-tables</p></li></ol><p>例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="meta">skip-grant-tables</span> <span class="string"># 添加这行</span></span><br><span class="line"><span class="comment"># skip-grant-tables=1</span></span><br><span class="line"><span class="attr">datadir</span>=<span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">socket</span>=<span class="string">/var/lib/mysql/mysql.sock</span></span><br></pre></td></tr></table></figure><p>重启mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p><br></p><h3 id="第二步用户无密码登录"><a href="#第二步用户无密码登录" class="headerlink" title="第二步用户无密码登录"></a>第二步用户无密码登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p (直接点击回车，密码为空)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="第三步选择数据库修改root密码"><a href="#第三步选择数据库修改root密码" class="headerlink" title="第三步选择数据库修改root密码"></a>第三步选择数据库修改root密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update mysql.user set authentication_string=password(&apos;新密码&apos;) where User=&apos;用户&apos;;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="第四步刷新并退出"><a href="#第四步刷新并退出" class="headerlink" title="第四步刷新并退出"></a>第四步刷新并退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="第五步编辑my-cnf并重启mysql"><a href="#第五步编辑my-cnf并重启mysql" class="headerlink" title="第五步编辑my.cnf并重启mysql"></a>第五步编辑my.cnf并重启mysql</h3><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 删除 skip-grant-tables  保存退出</span></span><br><span class="line">service mysql restart  <span class="comment"># 重启mysql</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://www.jb51.net/article/100211.htm" target="_blank" rel="noopener">文章1</a></li><li><a href="https://www.cnblogs.com/jekaysnow/p/8849533.html" target="_blank" rel="noopener">文章2</a></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql忘记密码解决方案</title>
      <link href="/2019/09/04/forget-mysql-password/"/>
      <url>/2019/09/04/forget-mysql-password/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>Mysql 忘记了密码 解决方案：</p><p><br></p><ol><li>Cmd – &gt; 停止mysql服务 （以管理员的身份） net stop mysql;</li><li>使用无验证方式启动mysql mysqld –skip-grant-tables</li><li>打开新的cmd窗口，直接输入mysql 回车 登录成功</li><li>依次执行 use mysql; set password for “root”@”localhost” = password(“新密码”);</li><li>手动执行mysqld的进程</li><li>启动mysql服务 net start mysql;</li><li>使用新密码登录</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springMVC配置定时任务</title>
      <link href="/2019/08/24/springMVC%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/08/24/springMVC%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><h2 id="springMVC配置定时执行任务"><a href="#springMVC配置定时执行任务" class="headerlink" title="springMVC配置定时执行任务"></a>springMVC配置定时执行任务</h2><h3 id="配置xml"><a href="#配置xml" class="headerlink" title="配置xml"></a>配置xml</h3><p>在SpringMVC配置文件中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task" </span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/task  </span><br><span class="line">http://www.springframework.org/schema/task/spring-task-4.3.xsd</span><br></pre></td></tr></table></figure><p>配置任务扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:annotation-driven /&gt;</span><br></pre></td></tr></table></figure><p>配置扫描任务位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描任务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.xxx.task"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://iqxqzx.gitee.io/pic/images/2019/8/24/1.png" alt="img"></p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kaoqin.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ? "</span>) <span class="comment">// 间隔5秒执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用SpringMVC框架配置定时任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>1、spring的 @Scheduled 注解 需要写在实现方法上</p><p>2、 定时器的任务方法不能有返回值（如果有返回值，spring初始化的时候会告诉你有个错误、需要设定一个proxytargetclass的某个值为true）</p><p>3、实现类上要有组件的注解@Component</p><p><strong>扩展：定时时间的设置</strong></p><p>如：“0/5 <em></em> <em></em> ?”</p><p>CronTrigger配置完整格式为： [秒] [分] [小时] [日] [月] [周] [年]</p><table><thead><tr><th>序号</th><th>说明</th><th>是否必填</th><th>允许填写的值</th><th>允许的通配符</th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>是</td><td>0-59</td><td>, - * /</td></tr><tr><td>2</td><td>分</td><td>是</td><td>0-59</td><td>, - * /</td></tr><tr><td>3</td><td>小时</td><td>是</td><td>0-23</td><td>, - * /</td></tr><tr><td>4</td><td>日</td><td>是</td><td>1-31</td><td>, - * ? / L W</td></tr><tr><td>5</td><td>月</td><td>是</td><td>1-12或JAN-DEC</td><td>, - * /</td></tr><tr><td>6</td><td>周</td><td>是</td><td>1-7或SUN-SAT</td><td>, - * ? / L W</td></tr><tr><td>7</td><td>年</td><td>否</td><td>empty 或1970-2099</td><td>, - * /</td></tr></tbody></table><p>通配符说明:</p><p>* 表示所有值. 例如:在分的字段上设置 “*”,表示每一分钟都会触发。</p><p>? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。</p><p>例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?</p><p>- 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。</p><p>, 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</p><p>/ 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。</p><p>L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”</p><p>W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“).</p><p># 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；</p><p><strong>小提示：</strong><br>‘L’和 ‘W’可以组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；<br>周字段的设置，若使用英文字母是不区分大小写的，即MON 与mon相同；</p><p>参考：</p><p><a href="https://wuzhuti.cn/850.html/comment-page-1/" target="_blank" rel="noopener">https://wuzhuti.cn/850.html/comment-page-1/</a></p><p><a href="https://wuzhuti.cn/447.html" target="_blank" rel="noopener">https://wuzhuti.cn/447.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表单onsubmit事件无效&amp;表单onsubmit后使用ajax无效解决</title>
      <link href="/2019/08/17/onsubmit-ajax-error/"/>
      <url>/2019/08/17/onsubmit-ajax-error/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>这段时间在写一个h5+app，用于一个组队比赛项目的app。由于自身也没有多少前端开发的经验，也就是闷着头一直乱写，在开发中也遇到了各种难题。</p><p>今天又解决一发问题，(此处需要掌声)， 成就感！</p><h3 id="关于登录表单submit的问题"><a href="#关于登录表单submit的问题" class="headerlink" title="关于登录表单submit的问题"></a>关于登录表单submit的问题</h3><p>这个过程需要用到的技术主要就是ajax技术和js的onsubmit技术。</p><p>过程如下：</p><blockquote><p>1.用户输入 用户名和密码</p><p>2.当用户点击提交按钮时，利用ajax请求后端接口 进行用户名密码验证。</p></blockquote><p>但是这时候出现一个问题，就是当 用户点击输入法的 <strong>发送</strong> <strong>提交</strong> 按钮的时候，我们怎么验证</p><p>这时候就需要原生js的 onsubmit 方法了</p><blockquote><p>3.1 验证不通过，onsubmit返回false，表单无法提交，页面提示用户密码有错。</p><p>3.2 验证通过，onsubmit返回true，表单提交，服务器返回用户内部视图，登陆成功。</p></blockquote><p>废话不说上代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击手机键盘  提交按钮</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"login"</span>).onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  subData();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 点击登录按钮</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"login-btn"</span>).addEventListener(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  subData();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取表单数据</span></span><br><span class="line">  <span class="keyword">var</span> data = getFormData(<span class="string">"login"</span>);</span><br><span class="line">  </span><br><span class="line">  mui.ajax(<span class="string">'http://192.168.1.142:8080/user/login.do'</span>, &#123;</span><br><span class="line">    data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="string">'username'</span>: data.username,</span><br><span class="line">      <span class="string">'password'</span>: data.password</span><br><span class="line">    &#125;),</span><br><span class="line">    dataType: <span class="string">'json'</span>, <span class="comment">//服务器返回json格式数据</span></span><br><span class="line">    type: <span class="string">'post'</span>, <span class="comment">//HTTP请求类型</span></span><br><span class="line">    timeout: <span class="number">10000</span>, <span class="comment">//超时时间设置为10秒；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  async: false, // 同步方式是为了解决   手机键盘提交按钮 提交表单验证bug的</span></span><br><span class="line">    </span><br><span class="line">    contentType: <span class="string">'application/json;charset=utf-8'</span>, <span class="comment">// 少了会报错</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">      <span class="keyword">if</span> (data.status == <span class="number">200</span>) &#123;</span><br><span class="line">        mui.toast(<span class="string">"登录成功"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.status == <span class="number">-200</span>) &#123;</span><br><span class="line">        mui.toast(<span class="string">"登录失败，请重新登录"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, type, errorThrown</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果用上面的代码，点击手机键盘 提交按钮 是无法完成验证操作的、</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>上面代码用的是 异步的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">checkpwd</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//1............</span></span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">//2........</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="comment">//3.........</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><p>如果是同步方式：当1执行完毕后，接着执行ajax，线程会处于等待状态，等2执行完毕之后，接着执行3.</p></li><li><p>如果是异步方式：当1执行完毕之后，接着执行ajax，但是ajax不会阻塞主线程，ajax执行的同时会执行3.</p></li></ul><p><br></p><p>下面展示错误的ajax验证方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击手机键盘  提交按钮</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"login"</span>).onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1........</span></span><br><span class="line">  </span><br><span class="line">  mui.ajax(<span class="string">'http://192.168.1.142:8080/user/login.do'</span>, &#123;</span><br><span class="line">    <span class="comment">// 2.......</span></span><br><span class="line">    data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="string">'username'</span>: data.username,</span><br><span class="line">      <span class="string">'password'</span>: data.password</span><br><span class="line">    &#125;),</span><br><span class="line">    dataType: <span class="string">'json'</span>, <span class="comment">//服务器返回json格式数据</span></span><br><span class="line">    type: <span class="string">'post'</span>, <span class="comment">//HTTP请求类型  </span></span><br><span class="line">    contentType: <span class="string">'application/json;charset=utf-8'</span>, <span class="comment">// 少了会报错</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"success"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, type, errorThrown</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3........</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>上面的代码， 先执行 1 后 执行 2 。但是2 (ajax) 不会阻塞主线程，2 (ajax) 执行的同时会执行3. 这时候3 没等验证成功，立马返回false</strong></p><p>因此，当使用异步方式进行验证的时候，会出现无论如何，onsubmit（onclick）都不会起作用，这会让程序员感觉自己的代码有问题，其实代码没问题，是逻辑的问题。要解决这个问题，我们就必须用ajax的同步方式。</p><p><br></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>改为同步方式 ajax 中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> : <span class="literal">false</span>,</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://my.oschina.net/qkmc/blog/872778" target="_blank" rel="noopener">文章1</a></li><li><a href></a></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML5+APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis查询parameterType多参数问题</title>
      <link href="/2019/08/15/Mybatis%E6%9F%A5%E8%AF%A2parameterType%E5%A4%9A%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/15/Mybatis%E6%9F%A5%E8%AF%A2parameterType%E5%A4%9A%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><h2 id="Mybatis查询parameterType多参数问题"><a href="#Mybatis查询parameterType多参数问题" class="headerlink" title="Mybatis查询parameterType多参数问题"></a>Mybatis查询parameterType多参数问题</h2><h3 id="一、单个参数："><a href="#一、单个参数：" class="headerlink" title="一、单个参数："></a>一、单个参数：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">List&lt;EntInfo&gt; <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"findByUsername"</span> resultMap=<span class="string">"EntInfoResultMap"</span> parameterType=<span class="string">"java.lang.String"</span> &gt;</span><br><span class="line">.......</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>其中方法名和ID一致，#{} 中的参数名与方法中的参数名一致， 这里采用的是@Param这个参数，实际上@Param这个最后会被Mabatis封装为map类型的。</p><p>select 后的字段列表要和bean中的属性名一致， 如果不一致的可以用 as 来补充。</p><h3 id="二、多参数："><a href="#二、多参数：" class="headerlink" title="二、多参数："></a>二、多参数：</h3><p>方案1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;XXX&gt; <span class="title">getXXX</span><span class="params">(String xxId, String xxCode)</span></span>;  </span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"getXXX"</span> resultType=<span class="string">"XXX"</span>&gt; <span class="comment">// 不需要写parameterType参数</span></span><br><span class="line"></span><br><span class="line">　　select t.* from tableName where id = #&#123;0&#125; and name = #&#123;1&#125;  </span><br><span class="line"></span><br><span class="line">&lt;/select&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于是多参数那么就不能使用parameterType， 改用#｛index｝是第几个就用第几个的索引，索引从0开始</span></span><br></pre></td></tr></table></figure><p>方案2（推荐）基于注解</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;XXXBean&gt; <span class="title">getXXXBeanList</span><span class="params">(@Param(<span class="string">"id"</span>)</span>String id, @<span class="title">Param</span><span class="params">(<span class="string">"code"</span>)</span>String code)</span>;  </span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"getXXXBeanList"</span> resultType=<span class="string">"XXBean"</span>&gt;</span><br><span class="line"></span><br><span class="line">　　select t.* from tableName where id = #&#123;id&#125; and name = #&#123;code&#125;  </span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>由于是多参数那么就不能使用parameterType， 这里用@Param来指定哪一个。</p><h3 id="三、map封装多参数："><a href="#三、map封装多参数：" class="headerlink" title="三、map封装多参数："></a>三、map封装多参数：</h3><p>通过传入map对象查询 并返回user对象的list集合</p><p>直接通过map里面的key直接访问 #{key}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsersByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">3</span>. 通过传入map对象查询 并返回user对象的list集合  map里面的属性直接访问 --&gt;</span><br><span class="line">&lt;select id=<span class="string">"findUsersByMap"</span> parameterType=<span class="string">"hashmap"</span> resultType=<span class="string">"user"</span>&gt;</span><br><span class="line">    select * from users where sex=#&#123;sex&#125; and username =#&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h3 id="四、List封装多个参数："><a href="#四、List封装多个参数：" class="headerlink" title="四、List封装多个参数："></a>四、List封装多个参数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;XXX&gt; <span class="title">getXXX</span><span class="params">(List&lt;String&gt; list)</span></span>;  </span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"getXXXBeanList"</span> resultType=<span class="string">"XXBean"</span>&gt;</span><br><span class="line">　　select 字段... from XXX where id in</span><br><span class="line">　　&lt;foreach item=<span class="string">"item"</span> index=<span class="string">"index"</span> collection=<span class="string">"list"</span> open=<span class="string">"("</span> separator=<span class="string">","</span> close=<span class="string">")"</span>&gt;  </span><br><span class="line">　　　　#&#123;item&#125;  </span><br><span class="line">　　&lt;/foreach&gt;  </span><br><span class="line">&lt;/select&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach 最后的效果是select 字段... from XXX where id in ('1','2','3','4')</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5+app实现文件上传(java后端)</title>
      <link href="/2019/08/13/HTML5-app%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-java%E5%90%8E%E7%AB%AF/"/>
      <url>/2019/08/13/HTML5-app%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-java%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>以拍照上传，相册选择图片上传为例</p><h3 id="HTML5-Plus-拍照或者相册选择图片上传到服务器"><a href="#HTML5-Plus-拍照或者相册选择图片上传到服务器" class="headerlink" title="HTML5 Plus 拍照或者相册选择图片上传到服务器"></a>HTML5 Plus 拍照或者相册选择图片上传到服务器</h3><p><br></p><p>起因：正在写一个人脸识别打卡签到的webApp，其中需要一个拍摄照片并上传服务器的功能</p><p>通过阅读<a href="http://www.html5plus.org/doc" target="_blank" rel="noopener">h5+官方文档</a> 了解到有相册 、相机、 文件上传等接口</p><h4 id="下面学习这几个api："><a href="#下面学习这几个api：" class="headerlink" title="下面学习这几个api："></a>下面学习这几个api：</h4><p>1、从图库选择图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">plus.gallery.pick(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;       <span class="comment">// path为选择图片的路径</span></span><br><span class="line">    <span class="comment">// 下面将图片显示在界面</span></span><br><span class="line">    hui(<span class="string">'#img3 div'</span>).hide();</span><br><span class="line">    hui(<span class="string">'#img3 img'</span>).attr(<span class="string">'src'</span>, path);</span><br><span class="line">    hui(<span class="string">'#img3 img'</span>).show();</span><br><span class="line">    <span class="comment">// 上传文件</span></span><br><span class="line">    imgUpload(path);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    hui.toast(<span class="string">"上传失败"</span>);</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    filter: <span class="string">'image'</span>,</span><br><span class="line">    system: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 选择多张图片</span></span><br><span class="line">plus.gallery.pick(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">paths</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> paths.files)&#123;</span><br><span class="line">      hui.toast(paths.files[i]);</span><br><span class="line">      <span class="comment">//imgUpload(path);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    hui.toast(<span class="string">'取消了选择'</span>);</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    filter: <span class="string">'image'</span>,</span><br><span class="line">    multiple: <span class="literal">true</span>,</span><br><span class="line">    maximum: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br></p><p>2、相机获取图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plus.camera.getCamera().captureImage(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个path 不能直接使用 是相对的  需要进行路径转换</span></span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">"file://"</span> + plus.io.convertLocalFileSystemURL(path); <span class="comment">// 路径转换</span></span><br><span class="line">    hui(<span class="string">'#img2 div'</span>).hide();</span><br><span class="line">    hui(<span class="string">'#img2 img'</span>).attr(<span class="string">'src'</span>, path);</span><br><span class="line">    hui(<span class="string">'#img2 img'</span>).show();</span><br><span class="line">    imgUpload(path);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    hui.toast(<span class="string">"上传失败"</span>);</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    index: <span class="number">2</span> <span class="comment">// 拍照时默认的摄像头 1后置 2 前置</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br></p><p>3、uploader文件上传</p><p>原理应该就是通过http 的post请求上传文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片上传（java后端测试成功）</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imgUpload</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  plus.nativeUI.showWaiting();</span><br><span class="line">  <span class="keyword">var</span> task = plus.uploader.createUpload(</span><br><span class="line">    <span class="string">'http://192.168.1.142:8080/img/upload.do'</span>, &#123;</span><br><span class="line">      method: <span class="string">"POST"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">resp, status</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (status == <span class="number">200</span>) &#123;</span><br><span class="line">        plus.nativeUI.closeWaiting();</span><br><span class="line">        <span class="built_in">console</span>.log(resp.responseText);</span><br><span class="line">        mui.toast(<span class="string">'上传成功'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mui.toast(<span class="string">'上传失败'</span>);</span><br><span class="line">        plus.nativeUI.closeWaiting();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  task.addFile(path, &#123;<span class="attr">key</span>: <span class="string">'file'</span>&#125;); <span class="comment">// 这里必须和 java后端的 @RequestParam(value = "file") 对应</span></span><br><span class="line">  task.addData(<span class="string">"name"</span>, <span class="string">"test"</span>);</span><br><span class="line">  task.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是上述所写，server为上传的服务端接口地址，如果上传成功，则回调的status会返回200，不成功或者接口参数有问题会返回400或者500。</p><p>resp.responseText 服务端返回的结果，一般服务端会返回json，解析一下json就可以使用了。</p><p><br></p><p>传输其他文件时如果还想添加其他参数，用.addData(key,value),</p><p>添加图片用.addFile(图片路径，{key:后端接收文件的名字})， <strong>这个key必须和后端接收名字对应</strong></p><p>配合后端代码看会好理解，后端我用java接收的：</p><p><br></p><p>4、Java后端接收并保存</p><p>用标准的MultipartFile接收即可。注意xml限制的大小设定</p><p>springMVC.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--单位字节--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"20480000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/upload"</span>, produces = <span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadImg</span><span class="params">(@RequestParam(value = <span class="string">"file"</span>)</span> MultipartFile file, HttpServletRequest request) </span>&#123;</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String oriFilename = file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件后缀</span></span><br><span class="line">    String fileType = oriFilename.substring(oriFilename.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>, oriFilename.length()).toLowerCase();</span><br><span class="line">    <span class="comment">// 存储路径</span></span><br><span class="line">    String basePath = <span class="string">"/Users/qxqzx/Desktop/img/"</span>;</span><br><span class="line">    <span class="comment">// 保存的文件名字</span></span><br><span class="line">    String saveName = String.valueOf(<span class="keyword">new</span> Date().getTime()) + <span class="string">"."</span> + fileType;</span><br><span class="line">    File dst = <span class="keyword">new</span> File(basePath, saveName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dst.getParentFile().exists()) &#123;</span><br><span class="line">      dst.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    file.transferTo(dst); <span class="comment">// 写入本地</span></span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">    map.put(<span class="string">"code"</span>, <span class="string">"200"</span>);</span><br><span class="line">    map.put(<span class="string">"msg"</span>, <span class="string">"图片上传成功！"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    map.put(<span class="string">"success"</span>, <span class="keyword">false</span>);</span><br><span class="line">    map.put(<span class="string">"code"</span>, <span class="string">"-200"</span>);</span><br><span class="line">    map.put(<span class="string">"msg"</span>, <span class="string">"图片上传失败！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JSON.toJSONString(map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时总结到这, 等后续补充</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML5+APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 报错 Cannot read property &#39;replace&#39; of null</title>
      <link href="/2019/08/12/hexo-%E6%8A%A5%E9%94%99-Cannot-read-property-replace-of-null/"/>
      <url>/2019/08/12/hexo-%E6%8A%A5%E9%94%99-Cannot-read-property-replace-of-null/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>hexo配置文件进行相应的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/qxqzx/qxqzx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>就报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FATAL Cannot read property &apos;replace&apos; of null</span><br></pre></td></tr></table></figure><p>解决：</p><blockquote><p>看帖子都是说 _config.yml 配置文件中的url 设置错误</p></blockquote><p>我的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; url: </span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>看了下url果然有错，加上url后好了</p><p>执行 hexo g -d 成功。</p><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://link.jianshu.com?t=https://github.com/hexojs/hexo/issues/2006" target="_blank" rel="noopener">hexo issues #2006</a><br><a href="https://link.jianshu.com?t=https://github.com/hexojs/hexo/issues/2141" target="_blank" rel="noopener">hexo issues #2141</a><br><a href="https://link.jianshu.com?t=http://www.cd2want.cc/2016/06/03/2016-06-03-从jekyll搬到Hexo/" target="_blank" rel="noopener">cd2want</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新启程，一个新的开始</title>
      <link href="/2019/08/12/%E6%96%B0%E5%90%AF%E7%A8%8B%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>/2019/08/12/%E6%96%B0%E5%90%AF%E7%A8%8B%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><h2 id="这是一个全新开始"><a href="#这是一个全新开始" class="headerlink" title="这是一个全新开始"></a>这是一个全新开始</h2><p>建立这个新的站点，来记录一些东西。</p><p>以前的站点 用的是typecho已经鸽了一个月，没更新内容。不在打算更新。</p><p>今天开始 转为 Hexo站点，原因是 这个主题太好看了</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo新开始</title>
      <link href="/2019/08/12/Hexo%E6%96%B0%E5%BC%80%E5%A7%8B/"/>
      <url>/2019/08/12/Hexo%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Dec 15 2019 18:40:45 GMT+0800 (中国标准时间) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
